module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/base64-js/index.js":
/*!***********************************************************!*\
  !*** /home/leif/moss/web/node_modules/base64-js/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:////home/leif/moss/web/node_modules/base64-js/index.js?");

/***/ }),

/***/ "../../node_modules/buffer/index.js":
/*!********************************************************!*\
  !*** /home/leif/moss/web/node_modules/buffer/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"../../node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"../../node_modules/buffer/node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"../../node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////home/leif/moss/web/node_modules/buffer/index.js?");

/***/ }),

/***/ "../../node_modules/buffer/node_modules/ieee754/index.js":
/*!*****************************************************************************!*\
  !*** /home/leif/moss/web/node_modules/buffer/node_modules/ieee754/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:////home/leif/moss/web/node_modules/buffer/node_modules/ieee754/index.js?");

/***/ }),

/***/ "../../node_modules/isarray/index.js":
/*!*********************************************************!*\
  !*** /home/leif/moss/web/node_modules/isarray/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:////home/leif/moss/web/node_modules/isarray/index.js?");

/***/ }),

/***/ "../../node_modules/moo/moo.js":
/*!***************************************************!*\
  !*** /home/leif/moss/web/node_modules/moo/moo.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) /* global define */\n  } else {}\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      if (obj.unicode) throw new Error('RegExp /u flag is not allowed')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    var value = token.text\n    var index = token.offset\n    var eol = token.lineBreaks ? value.indexOf('\\n') : value.length\n    var start = Math.max(0, index - token.col + 1)\n    var firstLine = this.buffer.substring(start, index + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n\n\n//# sourceURL=webpack:////home/leif/moss/web/node_modules/moo/moo.js?");

/***/ }),

/***/ "../../node_modules/nearley/lib/nearley.js":
/*!***************************************************************!*\
  !*** /home/leif/moss/web/node_modules/nearley/lib/nearley.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function(root, factory) {\n    if ( true && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        function stringifySymbolSequence (e) {\n            return e.literal ? JSON.stringify(e.literal) :\n                   e.type ? '%' + e.type : e.toString();\n        }\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(stringifySymbolSequence).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n            var col = this.index - this.lastLineBreak;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += \"  \" + line + \"\\n\"\n            message += \"  \" + Array(col).join(\" \") + \"^\"\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n    }\n\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (token = lexer.next()) {\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n                message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n                message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n                var err = new Error(message);\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n\n\n//# sourceURL=webpack:////home/leif/moss/web/node_modules/nearley/lib/nearley.js?");

/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "../typed-json-transform/lib/arrays.js":
/*!*********************************************!*\
  !*** ../typed-json-transform/lib/arrays.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar check_1 = __webpack_require__(/*! ./check */ \"../typed-json-transform/lib/check.js\");\nexports.compareAndFilter = function (arr1, arr2, fn, filter) {\n    var ret = [];\n    for (var i = 0; i < arr1.length; i++) {\n        var a = arr1[i];\n        var b = arr2[i];\n        var v = fn(a, b);\n        if (v || (check_1.check(v, Number)))\n            ret.push(v);\n    }\n    return ret;\n};\nfunction every(iter, fn) {\n    if (check_1.check(iter, Array)) {\n        var index = 0;\n        if (!iter.length)\n            return false;\n        try {\n            for (var _a = __values(iter), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var v = _b.value;\n                if (!fn(v, index)) {\n                    return false;\n                }\n                index++;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    if (check_1.check(iter, Object)) {\n        var keys = Object.keys(iter);\n        if (!keys.length)\n            return false;\n        try {\n            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                var k = keys_1_1.value;\n                if (!fn(iter[k], k)) {\n                    return false;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (keys_1_1 && !keys_1_1.done && (_d = keys_1.return)) _d.call(keys_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    return true;\n    var e_1, _c, e_2, _d;\n}\nexports.every = every;\nexports.all = every;\nvar Mutate;\n(function (Mutate) {\n    function concat() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var _a = __read(args), input = _a[0], rest = _a.slice(1);\n        try {\n            for (var rest_1 = __values(rest), rest_1_1 = rest_1.next(); !rest_1_1.done; rest_1_1 = rest_1.next()) {\n                var arr = rest_1_1.value;\n                try {\n                    for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\n                        var v = arr_1_1.value;\n                        input.push(v);\n                    }\n                }\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                finally {\n                    try {\n                        if (arr_1_1 && !arr_1_1.done && (_b = arr_1.return)) _b.call(arr_1);\n                    }\n                    finally { if (e_3) throw e_3.error; }\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (rest_1_1 && !rest_1_1.done && (_c = rest_1.return)) _c.call(rest_1);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        var e_4, _c, e_3, _b;\n    }\n    Mutate.concat = concat;\n    function assign(a, b) {\n        a.length = 0;\n        concat(a, b);\n    }\n    Mutate.assign = assign;\n    function deduplicate(input) {\n        var res = [];\n        try {\n            for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {\n                var v = input_1_1.value;\n                if (!contains(res, v)) {\n                    res.push(v);\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        assign(input, res);\n        var e_5, _a;\n    }\n    Mutate.deduplicate = deduplicate;\n    function union() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var _a = __read(args), input = _a[0], rest = _a.slice(1);\n        deduplicate(input);\n        try {\n            for (var rest_2 = __values(rest), rest_2_1 = rest_2.next(); !rest_2_1.done; rest_2_1 = rest_2.next()) {\n                var arr = rest_2_1.value;\n                try {\n                    for (var arr_2 = __values(arr), arr_2_1 = arr_2.next(); !arr_2_1.done; arr_2_1 = arr_2.next()) {\n                        var v = arr_2_1.value;\n                        if (!contains(input, v)) {\n                            input.push(v);\n                        }\n                    }\n                }\n                catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                finally {\n                    try {\n                        if (arr_2_1 && !arr_2_1.done && (_b = arr_2.return)) _b.call(arr_2);\n                    }\n                    finally { if (e_6) throw e_6.error; }\n                }\n            }\n        }\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\n        finally {\n            try {\n                if (rest_2_1 && !rest_2_1.done && (_c = rest_2.return)) _c.call(rest_2);\n            }\n            finally { if (e_7) throw e_7.error; }\n        }\n        var e_7, _c, e_6, _b;\n    }\n    Mutate.union = union;\n    function intersect() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var res = [];\n        var _loop_1 = function (a) {\n            var _loop_2 = function (v) {\n                if (!contains(res, v)) {\n                    if (every(args, function (b) {\n                        if (b == a) {\n                            return true;\n                        }\n                        return contains(b, v) > 0;\n                    })) {\n                        res.push(v);\n                    }\n                }\n            };\n            try {\n                for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {\n                    var v = a_1_1.value;\n                    _loop_2(v);\n                }\n            }\n            catch (e_8_1) { e_8 = { error: e_8_1 }; }\n            finally {\n                try {\n                    if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);\n                }\n                finally { if (e_8) throw e_8.error; }\n            }\n            var e_8, _a;\n        };\n        try {\n            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {\n                var a = args_1_1.value;\n                _loop_1(a);\n            }\n        }\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\n        finally {\n            try {\n                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);\n            }\n            finally { if (e_9) throw e_9.error; }\n        }\n        assign(args[0], res);\n        var e_9, _a;\n    }\n    Mutate.intersect = intersect;\n    function difference(a, b) {\n        var res = [];\n        try {\n            for (var b_1 = __values(b), b_1_1 = b_1.next(); !b_1_1.done; b_1_1 = b_1.next()) {\n                var v = b_1_1.value;\n                if (!contains(a, v)) {\n                    res.push(v);\n                }\n            }\n        }\n        catch (e_10_1) { e_10 = { error: e_10_1 }; }\n        finally {\n            try {\n                if (b_1_1 && !b_1_1.done && (_a = b_1.return)) _a.call(b_1);\n            }\n            finally { if (e_10) throw e_10.error; }\n        }\n        assign(a, res);\n        var e_10, _a;\n    }\n    Mutate.difference = difference;\n    function subtract(a, b) {\n        var res = [];\n        try {\n            for (var a_2 = __values(a), a_2_1 = a_2.next(); !a_2_1.done; a_2_1 = a_2.next()) {\n                var v = a_2_1.value;\n                if (!contains(b, v)) {\n                    res.push(v);\n                }\n            }\n        }\n        catch (e_11_1) { e_11 = { error: e_11_1 }; }\n        finally {\n            try {\n                if (a_2_1 && !a_2_1.done && (_a = a_2.return)) _a.call(a_2);\n            }\n            finally { if (e_11) throw e_11.error; }\n        }\n        assign(a, res);\n        var e_11, _a;\n    }\n    Mutate.subtract = subtract;\n    function xor(a, b) {\n        var res = [];\n        try {\n            for (var a_3 = __values(a), a_3_1 = a_3.next(); !a_3_1.done; a_3_1 = a_3.next()) {\n                var v = a_3_1.value;\n                if (!contains(b, v)) {\n                    res.push(v);\n                }\n            }\n        }\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\n        finally {\n            try {\n                if (a_3_1 && !a_3_1.done && (_a = a_3.return)) _a.call(a_3);\n            }\n            finally { if (e_12) throw e_12.error; }\n        }\n        try {\n            for (var b_2 = __values(b), b_2_1 = b_2.next(); !b_2_1.done; b_2_1 = b_2.next()) {\n                var v = b_2_1.value;\n                if (!contains(a, v)) {\n                    res.push(v);\n                }\n            }\n        }\n        catch (e_13_1) { e_13 = { error: e_13_1 }; }\n        finally {\n            try {\n                if (b_2_1 && !b_2_1.done && (_b = b_2.return)) _b.call(b_2);\n            }\n            finally { if (e_13) throw e_13.error; }\n        }\n        assign(a, res);\n        var e_12, _a, e_13, _b;\n    }\n    Mutate.xor = xor;\n    Mutate.compareAndFilter = function (arr1, arr2, fn, filter) {\n        var ret = [];\n        for (var i = 0; i < arr1.length; i++) {\n            var a = arr1[i];\n            var b = arr2[i];\n            var v = fn(a, b);\n            if (v || (check_1.check(v, Number)))\n                ret.push(v);\n        }\n        assign(arr1, ret);\n    };\n})(Mutate = exports.Mutate || (exports.Mutate = {}));\nfunction union() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var res = [];\n    try {\n        for (var args_2 = __values(args), args_2_1 = args_2.next(); !args_2_1.done; args_2_1 = args_2.next()) {\n            var arr = args_2_1.value;\n            try {\n                for (var arr_3 = __values(arr), arr_3_1 = arr_3.next(); !arr_3_1.done; arr_3_1 = arr_3.next()) {\n                    var v = arr_3_1.value;\n                    if (!contains(res, v)) {\n                        res.push(v);\n                    }\n                }\n            }\n            catch (e_14_1) { e_14 = { error: e_14_1 }; }\n            finally {\n                try {\n                    if (arr_3_1 && !arr_3_1.done && (_a = arr_3.return)) _a.call(arr_3);\n                }\n                finally { if (e_14) throw e_14.error; }\n            }\n        }\n    }\n    catch (e_15_1) { e_15 = { error: e_15_1 }; }\n    finally {\n        try {\n            if (args_2_1 && !args_2_1.done && (_b = args_2.return)) _b.call(args_2);\n        }\n        finally { if (e_15) throw e_15.error; }\n    }\n    return res;\n    var e_15, _b, e_14, _a;\n}\nexports.union = union;\nfunction concat() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var res = [];\n    try {\n        for (var args_3 = __values(args), args_3_1 = args_3.next(); !args_3_1.done; args_3_1 = args_3.next()) {\n            var arr = args_3_1.value;\n            try {\n                for (var arr_4 = __values(arr), arr_4_1 = arr_4.next(); !arr_4_1.done; arr_4_1 = arr_4.next()) {\n                    var v = arr_4_1.value;\n                    res.push(v);\n                }\n            }\n            catch (e_16_1) { e_16 = { error: e_16_1 }; }\n            finally {\n                try {\n                    if (arr_4_1 && !arr_4_1.done && (_a = arr_4.return)) _a.call(arr_4);\n                }\n                finally { if (e_16) throw e_16.error; }\n            }\n        }\n    }\n    catch (e_17_1) { e_17 = { error: e_17_1 }; }\n    finally {\n        try {\n            if (args_3_1 && !args_3_1.done && (_b = args_3.return)) _b.call(args_3);\n        }\n        finally { if (e_17) throw e_17.error; }\n    }\n    return res;\n    var e_17, _b, e_16, _a;\n}\nexports.concat = concat;\nfunction intersect() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var res = [];\n    var _loop_3 = function (a) {\n        var _loop_4 = function (v) {\n            if (!contains(res, v)) {\n                if (every(args, function (b) {\n                    if (b == a) {\n                        return true;\n                    }\n                    return contains(b, v) > 0;\n                })) {\n                    res.push(v);\n                }\n            }\n        };\n        try {\n            for (var a_4 = __values(a), a_4_1 = a_4.next(); !a_4_1.done; a_4_1 = a_4.next()) {\n                var v = a_4_1.value;\n                _loop_4(v);\n            }\n        }\n        catch (e_18_1) { e_18 = { error: e_18_1 }; }\n        finally {\n            try {\n                if (a_4_1 && !a_4_1.done && (_a = a_4.return)) _a.call(a_4);\n            }\n            finally { if (e_18) throw e_18.error; }\n        }\n        var e_18, _a;\n    };\n    try {\n        for (var args_4 = __values(args), args_4_1 = args_4.next(); !args_4_1.done; args_4_1 = args_4.next()) {\n            var a = args_4_1.value;\n            _loop_3(a);\n        }\n    }\n    catch (e_19_1) { e_19 = { error: e_19_1 }; }\n    finally {\n        try {\n            if (args_4_1 && !args_4_1.done && (_a = args_4.return)) _a.call(args_4);\n        }\n        finally { if (e_19) throw e_19.error; }\n    }\n    return res;\n    var e_19, _a;\n}\nexports.intersect = intersect;\nfunction difference(a, b) {\n    var res = [];\n    try {\n        for (var a_5 = __values(a), a_5_1 = a_5.next(); !a_5_1.done; a_5_1 = a_5.next()) {\n            var v = a_5_1.value;\n            if (!contains(b, v)) {\n                res.push(v);\n            }\n        }\n    }\n    catch (e_20_1) { e_20 = { error: e_20_1 }; }\n    finally {\n        try {\n            if (a_5_1 && !a_5_1.done && (_a = a_5.return)) _a.call(a_5);\n        }\n        finally { if (e_20) throw e_20.error; }\n    }\n    return res;\n    var e_20, _a;\n}\nexports.difference = difference;\nfunction arrayify(val) {\n    if (check_1.check(val, Array)) {\n        return val;\n    }\n    return [val];\n}\nexports.arrayify = arrayify;\nfunction contains(set, toMatch) {\n    if (check_1.check(toMatch, Array)) {\n        return containsAny(set, toMatch);\n    }\n    var matches = 0;\n    try {\n        for (var set_1 = __values(set), set_1_1 = set_1.next(); !set_1_1.done; set_1_1 = set_1.next()) {\n            var val = set_1_1.value;\n            if (check_1.isEqual(val, toMatch)) {\n                matches++;\n            }\n        }\n    }\n    catch (e_21_1) { e_21 = { error: e_21_1 }; }\n    finally {\n        try {\n            if (set_1_1 && !set_1_1.done && (_a = set_1.return)) _a.call(set_1);\n        }\n        finally { if (e_21) throw e_21.error; }\n    }\n    return matches;\n    var e_21, _a;\n}\nexports.contains = contains;\nfunction containsAny(set, match) {\n    if (!check_1.check(match, Array)) {\n        throw new Error('contains all takes a list to match');\n    }\n    var matches = 0;\n    try {\n        for (var match_1 = __values(match), match_1_1 = match_1.next(); !match_1_1.done; match_1_1 = match_1.next()) {\n            var val = match_1_1.value;\n            if (contains(set, val)) {\n                // return true;\n                matches++;\n            }\n        }\n    }\n    catch (e_22_1) { e_22 = { error: e_22_1 }; }\n    finally {\n        try {\n            if (match_1_1 && !match_1_1.done && (_a = match_1.return)) _a.call(match_1);\n        }\n        finally { if (e_22) throw e_22.error; }\n    }\n    return matches;\n    var e_22, _a;\n}\nexports.containsAny = containsAny;\nfunction containsAll(set, match) {\n    if (!check_1.check(match, Array)) {\n        throw new Error('contains all takes a list to match');\n    }\n    try {\n        for (var match_2 = __values(match), match_2_1 = match_2.next(); !match_2_1.done; match_2_1 = match_2.next()) {\n            var val = match_2_1.value;\n            if (!contains(set, val)) {\n                return false;\n            }\n        }\n    }\n    catch (e_23_1) { e_23 = { error: e_23_1 }; }\n    finally {\n        try {\n            if (match_2_1 && !match_2_1.done && (_a = match_2.return)) _a.call(match_2);\n        }\n        finally { if (e_23) throw e_23.error; }\n    }\n    return true;\n    var e_23, _a;\n}\nexports.containsAll = containsAll;\n//# sourceMappingURL=arrays.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/arrays.js?");

/***/ }),

/***/ "../typed-json-transform/lib/cascade.js":
/*!**********************************************!*\
  !*** ../typed-json-transform/lib/cascade.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrays_1 = __webpack_require__(/*! ./arrays */ \"../typed-json-transform/lib/arrays.js\");\nvar containers_1 = __webpack_require__(/*! ./containers */ \"../typed-json-transform/lib/containers.js\");\nvar keypath_1 = __webpack_require__(/*! ./keypath */ \"../typed-json-transform/lib/keypath.js\");\nvar string_1 = __webpack_require__(/*! ./string */ \"../typed-json-transform/lib/string.js\");\nfunction deepSearch(object, keywords, selectors) {\n    if (!object)\n        return;\n    if (!Object.keys(object).length)\n        return object;\n    var stack = [];\n    containers_1.each(keypath_1.keyPaths(object), function (key) {\n        var filtered = key;\n        var unfiltered = key.split('.');\n        var level = 0;\n        try {\n            for (var unfiltered_1 = __values(unfiltered), unfiltered_1_1 = unfiltered_1.next(); !unfiltered_1_1.done; unfiltered_1_1 = unfiltered_1.next()) {\n                var k = unfiltered_1_1.value;\n                if (select(keywords, k)) {\n                    var precedence = select(selectors, k);\n                    if (precedence > 0) {\n                        filtered = filtered.replace(k + \".\", '').replace(\".\" + k, '');\n                        level += precedence;\n                    }\n                    else {\n                        return;\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (unfiltered_1_1 && !unfiltered_1_1.done && (_a = unfiltered_1.return)) _a.call(unfiltered_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        ;\n        if (!stack[level]) {\n            stack[level] = {};\n        }\n        stack[level][filtered] = keypath_1.valueForKeyPath(key, object);\n        var e_1, _a;\n    });\n    return stack;\n}\nfunction flatten(stack, fn) {\n    var flat = {};\n    var apply = fn || keypath_1.mergeValueAtKeypath;\n    containers_1.each(stack, function (level, height) {\n        if (level) {\n            containers_1.each(level, function (v, kp) {\n                apply(v, kp, flat);\n            });\n        }\n    });\n    return flat;\n}\nfunction matchSelector(selectors, selectable) {\n    if (string_1.startsWith(selectable, '!')) {\n        return 1 * !arrays_1.contains(selectors, selectable.slice(1));\n    }\n    return 1 * arrays_1.contains(selectors, selectable);\n}\nfunction matchEvery(selectedList, selectorString) {\n    if (selectorString.indexOf(' ') !== -1) {\n        var selectables = selectorString.split(' ');\n        return containers_1.sumIfEvery(selectables, function (selectable) {\n            return matchSelector(selectedList, selectable);\n        });\n    }\n    return matchSelector(selectedList, selectorString);\n}\nfunction matchSelectorString(selectedList, selectorString) {\n    var selectables = string_1.replaceAll(selectorString, ', ', ',');\n    if (selectables.indexOf(',') !== -1) {\n        return containers_1.greatestResult(selectables.split(','), function (subCssString) {\n            return matchEvery(selectedList, subCssString);\n        });\n    }\n    return matchEvery(selectedList, selectables);\n}\nfunction select(input, cssString) {\n    return matchSelectorString(input, cssString);\n}\nexports.select = select;\nfunction extractKeywordsAndSelectors(options) {\n    var keywords = [];\n    var selectors = [];\n    containers_1.each(options, function (opt, key) {\n        keywords.push(key);\n        if (opt)\n            selectors.push(key);\n    });\n    return {\n        keywords: keywords, selectors: selectors\n    };\n}\nexports.extractKeywordsAndSelectors = extractKeywordsAndSelectors;\nfunction hashField(trie, options) {\n    var _a = extractKeywordsAndSelectors(options), keywords = _a.keywords, selectors = _a.selectors;\n    var match = flatten(deepSearch(trie, keywords, selectors));\n    var unselected = containers_1.okmap(trie, function (val) {\n        return false;\n    });\n    var selected = containers_1.okmap(match, function (val) {\n        return !!val;\n    });\n    return containers_1.or(unselected, selected);\n}\nexports.hashField = hashField;\nfunction cascade(tree, keywords, selectors, apply) {\n    return flatten(deepSearch(tree, keywords, selectors), apply);\n}\nexports.cascade = cascade;\n//# sourceMappingURL=cascade.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/cascade.js?");

/***/ }),

/***/ "../typed-json-transform/lib/check.js":
/*!********************************************!*\
  !*** ../typed-json-transform/lib/check.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction check(val, type) {\n    if (_c(type, Array)) {\n        try {\n            for (var type_1 = __values(type), type_1_1 = type_1.next(); !type_1_1.done; type_1_1 = type_1.next()) {\n                var sType = type_1_1.value;\n                if (_c(val, sType)) {\n                    return true;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (type_1_1 && !type_1_1.done && (_a = type_1.return)) _a.call(type_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return false;\n    }\n    // if (type && type.prototype) { console.log(new Error().stack); return val && val.prototype == type.prototype; }\n    return _c(val, type);\n    var e_1, _a;\n}\nexports.check = check;\nexports.MapLike = 'MapLike';\nfunction _c(val, type) {\n    switch (type) {\n        case Array:\n        case 'Array':\n            return Array.isArray(val);\n        case Date:\n        case 'Date':\n            return val !== undefined && val instanceof Date;\n        case exports.MapLike:\n        case 'MapLike':\n            return (val instanceof Map) || _c(val, Object);\n        case Map:\n        case 'Map':\n            return val instanceof Map;\n        case Object:\n        case 'Object':\n            return val !== null && typeof val === 'object' && !_c(val, Date) && !_c(val, Array) && !_c(val, Error);\n        case String:\n        case 'String':\n            return typeof val === 'string';\n        case Number:\n        case 'Number':\n            return exports.isNumeric(val);\n        case Function:\n        case 'Function':\n            return (val !== null && typeof val === 'function');\n        case Boolean:\n        case 'Boolean':\n            return typeof val === 'boolean';\n        case Number:\n        case 'Number':\n            return exports.isNumeric(val);\n        case 'undefined':\n        case undefined:\n        case 'Undefined':\n            return val === undefined;\n        case null:\n            return val === null;\n        case Error:\n        case 'Error':\n            return val instanceof Error;\n        case 'any':\n            return (val !== null && val !== undefined) || exports.isNumeric(val);\n        default:\n            return val !== undefined && (val.constructor === type || val.prototype == type.prototype);\n    }\n}\nexports.isNumeric = function (n) { return !isNaN(parseFloat(n)) && isFinite(n); };\nexports.isArguments = function (object) { return Object.prototype.toString.call(object) == '[object Arguments]'; };\nfunction isEmpty(input) {\n    var ref = input;\n    if (!check(input, Object)) {\n        throw new Error('checking non object for non-empty keys');\n    }\n    var containsValid = false;\n    try {\n        for (var _a = __values(Object.keys(ref)), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var k = _b.value;\n            if (check(ref[k], 'any')) {\n                containsValid = true;\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return !containsValid;\n    var e_2, _d;\n}\nexports.isEmpty = isEmpty;\nexports.isUndefinedOrNull = function (value) { return value === null || value === undefined; };\nfunction isBuffer(x) {\n    if (!x || typeof x !== 'object' || typeof x.length !== 'number')\n        return false;\n    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n        return false;\n    }\n    if (x.length > 0 && typeof x[0] !== 'number')\n        return false;\n    return true;\n}\nexports.isBuffer = isBuffer;\nfunction isEqual(a, e, opts) {\n    // http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n    if (!opts)\n        opts = {};\n    // 7.1. All identical values are equivalent, as determined by ===.\n    if (a === e) {\n        return true;\n    }\n    else if (a instanceof Date && e instanceof Date) {\n        return a.getTime() === e.getTime();\n        // 7.3. Other pairs that do not both pass typeof value == 'object',\n        // equivalence is determined by ==.\n    }\n    else if (!a || !e || typeof a != 'object' && typeof e != 'object') {\n        return opts.strict ? a === e : a == e;\n        // 7.4. For all other Object pairs, including Array objects, equivalence is\n        // determined by having the same number of owned properties (as verified\n        // with Object.prototype.hasOwnProperty.call), the same set of keys\n        // (although not necessarily the same order), equivalent values for every\n        // corresponding key, and an identical 'prototype' property. Note: this\n        // accounts for both named and indexed properties on Arrays.\n    }\n    return _objEquiv(a, e, opts);\n}\nexports.isEqual = isEqual;\nvar pSlice = Array.prototype.slice;\nvar compareBuffer = function (a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n};\nfunction _objEquiv(a, b, opts) {\n    if (exports.isUndefinedOrNull(a) || exports.isUndefinedOrNull(b))\n        return false;\n    // an identical 'prototype' property.\n    if (a.prototype !== b.prototype)\n        return false;\n    //~~~I've managed to break Object.keys through screwy arguments passing.\n    //   Converting to array solves the problem.\n    if (exports.isArguments(a)) {\n        if (!exports.isArguments(b))\n            return false;\n        a = pSlice.call(a);\n        b = pSlice.call(b);\n        return isEqual(a, b, opts);\n    }\n    if (isBuffer(a)) {\n        if (!isBuffer(b))\n            return false;\n        return compareBuffer(a, b);\n    }\n    var ka, kb;\n    try {\n        ka = Object.keys(a);\n        kb = Object.keys(b);\n    }\n    catch (e) { //happens when one is a string literal and the other isn't\n        return false;\n    }\n    // having the same number of owned properties (keys incorporates\n    // hasOwnProperty)\n    if (ka.length != kb.length)\n        return false;\n    //the same set of keys (although not necessarily the same order),\n    ka.sort();\n    kb.sort();\n    //~~~cheap key test\n    for (var i = ka.length - 1; i >= 0; i--) {\n        if (ka[i] != kb[i])\n            return false;\n    }\n    //equivalent values for every corresponding key, and\n    //~~~possibly expensive deep test\n    for (var i = ka.length - 1; i >= 0; i--) {\n        var key = ka[i];\n        if (!isEqual(a[key], b[key], opts))\n            return false;\n    }\n    return typeof a === typeof b;\n}\n//# sourceMappingURL=check.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/check.js?");

/***/ }),

/***/ "../typed-json-transform/lib/containers.js":
/*!*************************************************!*\
  !*** ../typed-json-transform/lib/containers.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n///<reference path=\"../@types/index.d.ts\" />\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar check_1 = __webpack_require__(/*! ./check */ \"../typed-json-transform/lib/check.js\");\nvar decycle_1 = __webpack_require__(/*! ./decycle */ \"../typed-json-transform/lib/decycle.js\");\nvar merge_1 = __webpack_require__(/*! ./merge */ \"../typed-json-transform/lib/merge.js\");\nvar arrays_1 = __webpack_require__(/*! ./arrays */ \"../typed-json-transform/lib/arrays.js\");\nexports.set = function (t, _a) {\n    var _b = __read(_a, 2), k = _b[0], v = _b[1];\n    if (t instanceof Map) {\n        t.set(k, v);\n    }\n    else {\n        t[k] = v;\n    }\n};\nexports.unset = function (t, k) {\n    if (t instanceof Map) {\n        t.delete(k);\n    }\n    else {\n        delete t[k];\n    }\n};\nexports.get = function (s, k) {\n    return (s instanceof Map) ?\n        s.get(k)\n        :\n            s[k];\n};\nfunction each(iter, fn) {\n    var broken = 0;\n    var breakLoop = (function () { broken = 1; });\n    if (Array.isArray(iter)) {\n        var index = 0;\n        try {\n            for (var iter_1 = __values(iter), iter_1_1 = iter_1.next(); !iter_1_1.done; iter_1_1 = iter_1.next()) {\n                var v = iter_1_1.value;\n                fn(v, index, breakLoop);\n                if (broken) {\n                    return;\n                }\n                index++;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iter_1_1 && !iter_1_1.done && (_a = iter_1.return)) _a.call(iter_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    else if (iter instanceof Map) {\n        try {\n            for (var iter_2 = __values(iter), iter_2_1 = iter_2.next(); !iter_2_1.done; iter_2_1 = iter_2.next()) {\n                var _b = __read(iter_2_1.value, 2), k = _b[0], v = _b[1];\n                fn(v, k, breakLoop);\n                if (broken) {\n                    return;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (iter_2_1 && !iter_2_1.done && (_c = iter_2.return)) _c.call(iter_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    else {\n        try {\n            for (var _d = __values(Object.keys(iter)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var k = _e.value;\n                fn(iter[k], k, breakLoop);\n                if (broken) {\n                    return;\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n    }\n    var e_1, _a, e_2, _c, e_3, _f;\n}\nexports.each = each;\nfunction replace(target, source) {\n    each(source, function (v, k) { return exports.unset(target, k); });\n    return extend(target, source);\n}\nexports.replace = replace;\nfunction extend(target, source) {\n    if (check_1.check(source, check_1.MapLike)) {\n        return extendN(target, source);\n    }\n    return target;\n}\nexports.extend = extend;\nfunction extendOwn(target, source) {\n    each(source, function (rhs, key) {\n        var lhs = exports.get(target, key);\n        if (check_1.check(lhs, check_1.MapLike) && check_1.check(rhs, check_1.MapLike)) {\n            extendOwn(lhs, rhs);\n        }\n        else if (lhs) {\n            exports.set(target, [key, clone(exports.get(source, key))]);\n        }\n    });\n    return target;\n}\nexports.extendOwn = extendOwn;\nfunction existentialExtend(target, source) {\n    each(source, function (v, key) {\n        var lhs = exports.get(target, key);\n        var rhs = exports.get(source, key);\n        if (!lhs) {\n            exports.set(target, [key, clone(rhs)]);\n        }\n        else if (check_1.check(lhs, check_1.MapLike) && check_1.check(rhs, check_1.MapLike)) {\n            existentialExtend(lhs, rhs);\n        }\n    });\n    return target;\n}\nexports.existentialExtend = existentialExtend;\nfunction extendN(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    try {\n        for (var sources_1 = __values(sources), sources_1_1 = sources_1.next(); !sources_1_1.done; sources_1_1 = sources_1.next()) {\n            var source = sources_1_1.value;\n            each(source, function (v, k) { return exports.set(target, [k, v]); });\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (sources_1_1 && !sources_1_1.done && (_a = sources_1.return)) _a.call(sources_1);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    return target;\n    var e_4, _a;\n}\nexports.extendN = extendN;\nfunction flatten(arr) {\n    var stack = [];\n    try {\n        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\n            var v = arr_1_1.value;\n            if (check_1.check(v, Array)) {\n                arrays_1.Mutate.concat(stack, flatten(v));\n            }\n            else {\n                stack.push(v);\n            }\n        }\n    }\n    catch (e_5_1) { e_5 = { error: e_5_1 }; }\n    finally {\n        try {\n            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);\n        }\n        finally { if (e_5) throw e_5.error; }\n    }\n    return stack;\n    var e_5, _a;\n}\nexports.flatten = flatten;\nfunction keysAndValues(object) {\n    var keys = [];\n    var values = [];\n    each(object, function (v, k) {\n        keys.push(k);\n        values.push(v);\n    });\n    return { keys: keys, values: values };\n}\nexports.keysAndValues = keysAndValues;\nfunction assign(a, b) {\n    var result = clone(a);\n    return extend(result || {}, clone(b));\n}\nexports.assign = assign;\nfunction combine(a, b) {\n    var result = clone(a);\n    return extend(result || {}, clone(b));\n}\nexports.combine = combine;\nfunction combineN(retType) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var result = clone(retType);\n    try {\n        for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {\n            var dict = args_1_1.value;\n            if (check_1.check(dict, Object)) {\n                extend(result, dict);\n            }\n        }\n    }\n    catch (e_6_1) { e_6 = { error: e_6_1 }; }\n    finally {\n        try {\n            if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);\n        }\n        finally { if (e_6) throw e_6.error; }\n    }\n    return result;\n    var e_6, _a;\n}\nexports.combineN = combineN;\nfunction merge(target, setter, state) {\n    var res = merge_1.mergeOrReturnAssignment({\n        data: target, state: __assign({ merge: {\n                operator: '|'\n            } }, state)\n    }, setter).data;\n    if (res || check_1.check(res, Number)) {\n        return res;\n    }\n    return target;\n}\nexports.merge = merge;\nfunction mergeN(target) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    try {\n        for (var args_2 = __values(args), args_2_1 = args_2.next(); !args_2_1.done; args_2_1 = args_2.next()) {\n            var dict = args_2_1.value;\n            if (check_1.check(dict, Object)) {\n                merge(target, dict);\n            }\n        }\n    }\n    catch (e_7_1) { e_7 = { error: e_7_1 }; }\n    finally {\n        try {\n            if (args_2_1 && !args_2_1.done && (_a = args_2.return)) _a.call(args_2);\n        }\n        finally { if (e_7) throw e_7.error; }\n    }\n    return target;\n    var e_7, _a;\n}\nexports.mergeN = mergeN;\nfunction or(a, b) {\n    var ret = clone(a);\n    each(b, function (v, k) {\n        ret[k] = a[k] || b[k];\n    });\n    return ret;\n}\nexports.or = or;\nfunction any(iter, fn) {\n    if (check_1.check(iter, Array)) {\n        var index = 0;\n        try {\n            for (var _a = __values(iter), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var v = _b.value;\n                if (fn(v, index)) {\n                    return true;\n                }\n                index++;\n            }\n        }\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            }\n            finally { if (e_8) throw e_8.error; }\n        }\n    }\n    if (check_1.check(iter, Object)) {\n        try {\n            for (var _d = __values(Object.keys(iter)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var k = _e.value;\n                if (fn(iter[k], k)) {\n                    return true;\n                }\n            }\n        }\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n            }\n            finally { if (e_9) throw e_9.error; }\n        }\n    }\n    return false;\n    var e_8, _c, e_9, _f;\n}\nexports.any = any;\nfunction map(iter, fn) {\n    var res = [];\n    if (check_1.check(iter, Array)) {\n        var i = 0;\n        try {\n            for (var _a = __values(iter), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var v = _b.value;\n                res.push(fn(v, i));\n                i++;\n            }\n        }\n        catch (e_10_1) { e_10 = { error: e_10_1 }; }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            }\n            finally { if (e_10) throw e_10.error; }\n        }\n    }\n    if (check_1.check(iter, Object)) {\n        try {\n            for (var _d = __values(Object.keys(iter)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var k = _e.value;\n                res.push(fn(iter[k], k));\n            }\n        }\n        catch (e_11_1) { e_11 = { error: e_11_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n            }\n            finally { if (e_11) throw e_11.error; }\n        }\n    }\n    return res;\n    var e_10, _c, e_11, _f;\n}\nexports.map = map;\nfunction amap(iter, fn) {\n    var arr = [];\n    if (check_1.check(iter, Array)) {\n        var i = 0;\n        try {\n            for (var _a = __values(iter), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var v = _b.value;\n                arr.push(fn(v, i));\n                i++;\n            }\n        }\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            }\n            finally { if (e_12) throw e_12.error; }\n        }\n    }\n    if (check_1.check(iter, Object)) {\n        try {\n            for (var _d = __values(Object.keys(iter)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var k = _e.value;\n                arr.push(fn(iter[k], k));\n            }\n        }\n        catch (e_13_1) { e_13 = { error: e_13_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n            }\n            finally { if (e_13) throw e_13.error; }\n        }\n    }\n    return Promise.all(arr);\n    var e_12, _c, e_13, _f;\n}\nexports.amap = amap;\nfunction reduce(input, fn, base) {\n    var sum = base;\n    each(input, function (value) {\n        sum = fn(value, sum);\n    });\n    return sum;\n}\nexports.reduce = reduce;\nfunction sum(input, fn) {\n    var sum = 0;\n    each(input, function (value) {\n        sum = sum + fn(value);\n    });\n    return sum;\n}\nexports.sum = sum;\nfunction greatestResult(input, fn) {\n    var greatestResult = 0;\n    each(input, function (value) {\n        var res = fn(value);\n        if (res > greatestResult)\n            greatestResult = res;\n    });\n    return greatestResult;\n}\nexports.greatestResult = greatestResult;\nfunction sumIfEvery(input, fn) {\n    var sum = 0;\n    each(input, function (value, index, breakLoop) {\n        var res = fn(value);\n        if (res > 0) {\n            sum = sum + res;\n        }\n        else {\n            sum = 0;\n            breakLoop();\n        }\n    });\n    return sum;\n}\nexports.sumIfEvery = sumIfEvery;\nfunction geoSum(input, fn) {\n    var sum = 1;\n    each(input, function (value, key, breakLoop) {\n        sum *= fn(value, sum);\n    });\n    return sum;\n}\nexports.geoSum = geoSum;\nfunction _prune(input) {\n    if (!check_1.check(input, Object)) {\n        throw new Error('attempting to _prune undefined object');\n    }\n    var ref = input;\n    var pruned = false;\n    each(ref, function (val, k) {\n        if (check_1.check(val, Object)) {\n            if (_prune(val)) {\n                pruned = true;\n            }\n            if (check_1.isEmpty(val)) {\n                exports.unset(ref, k);\n                pruned = true;\n            }\n        }\n        if (val === undefined) {\n            exports.unset(ref, k);\n        }\n    });\n    return pruned;\n}\nfunction prune(obj) {\n    _prune(obj);\n    return obj;\n}\nexports.prune = prune;\nfunction clean(obj) {\n    try {\n        for (var _a = __values(Object.keys(obj)), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var key = _b.value;\n            delete obj[key];\n        }\n    }\n    catch (e_14_1) { e_14 = { error: e_14_1 }; }\n    finally {\n        try {\n            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        }\n        finally { if (e_14) throw e_14.error; }\n    }\n    return obj;\n    var e_14, _c;\n}\nexports.clean = clean;\nfunction plain(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.plain = plain;\nfunction ObjectAssign(target, source) {\n    var from;\n    var to = target;\n    var index = 0;\n    var total = arguments.length;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    while (++index < total) {\n        from = arguments[index];\n        if (from != null) {\n            for (var key in from) {\n                if (hasOwnProperty.call(from, key)) {\n                    to[key] = from[key];\n                }\n            }\n        }\n    }\n    return to;\n}\nfunction clone(obj, stacktrace, addr) {\n    if (stacktrace === void 0) { stacktrace = []; }\n    if (addr === void 0) { addr = []; }\n    var copy;\n    // Handle the 3 simple types, and null or undefined\n    if (null == obj || (\"object\" != typeof obj))\n        return obj;\n    each(addr, function (ptr) {\n        each(obj, function (v, key) {\n            if (ptr === v) {\n                throw new Error(\"terminate recursive clone @ \" + key + \"; \" + v + \" = \" + ptr + \" stack: \" + stacktrace.join('.') + \", addr: \" + addr + \"}\");\n            }\n        });\n    });\n    // Handle Date\n    if (obj instanceof Date) {\n        copy = new Date();\n        copy.setTime(obj.getTime());\n        return copy;\n    }\n    // Handle Array\n    else if (obj instanceof Array) {\n        copy = [];\n        for (var i = 0, len = obj.length; i < len; i++) {\n            copy[i] = clone(obj[i], __spread(stacktrace, [\"[\" + i + \"]\"]), __spread(addr, [obj]));\n        }\n        return copy;\n    }\n    // Handle Map\n    else if (obj instanceof Map) {\n        copy = new Map();\n        try {\n            for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {\n                var _a = __read(obj_1_1.value, 2), k = _a[0], v = _a[1];\n                copy.set(k, clone(v, __spread(stacktrace, [\"[\" + i + \"]\"]), __spread(addr, [obj])));\n            }\n        }\n        catch (e_15_1) { e_15 = { error: e_15_1 }; }\n        finally {\n            try {\n                if (obj_1_1 && !obj_1_1.done && (_b = obj_1.return)) _b.call(obj_1);\n            }\n            finally { if (e_15) throw e_15.error; }\n        }\n        return copy;\n    }\n    // force to handle as object even if instanceof Object returns null i.e. Object.create(null)\n    else {\n        var copy_1 = {};\n        if (obj != null) {\n            if (obj.clone) {\n                try {\n                    return obj.clone(obj);\n                }\n                catch (e) {\n                    throw new Error(typeof obj + \" instance: clone(\" + obj + \") failed\");\n                }\n            }\n            else if (obj.constructor) {\n                try {\n                    copy_1 = new (obj.constructor)();\n                }\n                catch (e) {\n                    throw new Error(\"Error while cloning a(n) [ \" + typeof obj + \" ] instance: \" + JSON.stringify(obj));\n                    // throw new Error(`${typeof obj} instance: ${from.constructor}() failed: ${e.message}`);\n                }\n            }\n            each(obj, function (v, key) {\n                copy_1[key] = clone(v, __spread(stacktrace, [key]), __spread(addr, [obj]));\n            });\n        }\n        return copy_1;\n    }\n    var e_15, _b;\n}\nexports.clone = clone;\nfunction okmap(iterable, fn) {\n    var o = {};\n    var a = [];\n    each(iterable, function (_v, _k) {\n        var k = _k;\n        var v = fn(_v, k);\n        if (check_1.check(v, Object)) {\n            var keys = Object.keys(v);\n            if (keys.length == 2 && (keys[0] == 'key' || keys[1] == 'key')) {\n                k = v.key;\n                v = v.value;\n            }\n        }\n        o[k] = v;\n        if (k >= 0) {\n            a[k] = v;\n        }\n    });\n    if (arrays_1.every(Object.keys(o), function (k) { return check_1.check(k, Number); }))\n        return a;\n    return o;\n}\nexports.okmap = okmap;\nfunction aokmap(iterable, fn) {\n    var createPromise = function (_v, _k) { return new Promise(function (resolve, reject) {\n        var key = _k;\n        return Promise.resolve(fn(_v, key)).then(function (value) {\n            if (check_1.check(value, Object)) {\n                var keys = Object.keys(value);\n                if (keys.length == 2 && (keys[0] == 'key' || keys[1] == 'key')) {\n                    key = value.key;\n                    value = value.value;\n                }\n            }\n            return resolve({ key: key, value: value });\n        }, function (e) { return reject(e); }).catch(function (e) { return reject(e); });\n    }); };\n    var pa = [];\n    each(iterable, function (_v, _k) {\n        pa.push(createPromise(_v, _k));\n    });\n    return Promise.all(pa).then(function (resolved) {\n        if (arrays_1.every(resolved, function (kv) { return check_1.check(kv.key, Number); })) {\n            var r_1 = [];\n            each(resolved, function (kv) {\n                r_1[kv.key] = kv.value;\n            });\n            return Promise.resolve(r_1);\n        }\n        else {\n            var r_2 = {};\n            each(resolved, function (kv) {\n                r_2[kv.key] = kv.value;\n            });\n            return Promise.resolve(r_2);\n        }\n    });\n}\nexports.aokmap = aokmap;\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(decycle_1.decycle(value), replacer, space || 2);\n}\nexports.stringify = stringify;\n//# sourceMappingURL=containers.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/containers.js?");

/***/ }),

/***/ "../typed-json-transform/lib/decycle.js":
/*!**********************************************!*\
  !*** ../typed-json-transform/lib/decycle.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction decycle(object) {\n    var objects = []; // Keep a reference to each unique object or array\n    var paths = []; // Keep the path to each unique object or array\n    return (function derez(value, path) {\n        // The derez recurses through the object, producing the deep copy.\n        var i; // The loop counter\n        var name; // Property name\n        var nu;\n        // typeof null === 'object', so go on if this value is really an object but not\n        // one of the weird builtin objects.\n        if (value != undefined && value instanceof Date) {\n            return new Date(value.valueOf());\n        }\n        if (typeof value === 'object' && value !== null) {\n            // If the value is an object or array, look to see if we have already\n            // encountered it. If so, return a $ref/path object. This is a hard way,\n            // linear search that will get slower as the number of unique objects grows.\n            for (i = 0; i < objects.length; i += 1) {\n                if (objects[i] === value) {\n                    return { $ref: paths[i] };\n                }\n            }\n            // Otherwise, accumulate the unique value and its path.\n            objects.push(value);\n            paths.push(path);\n            // If it is an array, replicate the array.\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                nu = [];\n                for (i = 0; i < value.length; i += 1) {\n                    nu[i] = derez(value[i], path + '[' + i + ']');\n                }\n            }\n            else {\n                // If it is an object, replicate the object.\n                nu = {};\n                for (name in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n                        nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n                    }\n                }\n            }\n            return nu;\n        }\n        return value;\n    }(object, '$'));\n}\nexports.decycle = decycle;\nfunction retrocycle($) {\n    var px = /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/;\n    (function rez(value) {\n        // The rez function walks recursively through the object looking for $ref\n        // properties. When it finds one that has a value that is a path, then it\n        // replaces the $ref object with a reference to the value that is found by\n        // the path.\n        var i, item, name, path;\n        if (value && typeof value === 'object') {\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                for (i = 0; i < value.length; i += 1) {\n                    item = value[i];\n                    if (item && typeof item === 'object') {\n                        path = item.$ref;\n                        if (typeof path === 'string' && px.test(path)) {\n                            value[i] = eval(path);\n                        }\n                        else {\n                            rez(item);\n                        }\n                    }\n                }\n            }\n            else {\n                for (name in value) {\n                    if (typeof value[name] === 'object') {\n                        item = value[name];\n                        if (item) {\n                            path = item.$ref;\n                            if (typeof path === 'string' && px.test(path)) {\n                                value[name] = eval(path);\n                            }\n                            else {\n                                rez(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }($));\n    return $;\n}\nexports.retrocycle = retrocycle;\n//# sourceMappingURL=decycle.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/decycle.js?");

/***/ }),

/***/ "../typed-json-transform/lib/graph.js":
/*!********************************************!*\
  !*** ../typed-json-transform/lib/graph.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\nthis libary is a TypeScript port of a js library written by Jim Riecken\nhttps://github.com/jriecken/dependency-graph\n*/\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar containers_1 = __webpack_require__(/*! ./containers */ \"../typed-json-transform/lib/containers.js\");\nvar Graph = /** @class */ (function () {\n    function Graph() {\n        this.nodes = {};\n        this.outgoingEdges = {}; // Node -> [Dependency Node]\n        this.incomingEdges = {}; // Node -> [Dependant Node]\n    }\n    Graph.prototype.addNode = function (node, data) {\n        if (!this.hasNode(node)) {\n            if (arguments.length === 2) {\n                this.nodes[node] = data;\n            }\n            else {\n                this.nodes[node] = node;\n            }\n            this.outgoingEdges[node] = [];\n            this.incomingEdges[node] = [];\n        }\n    };\n    Graph.prototype.removeNode = function (node) {\n        if (this.hasNode(node)) {\n            delete this.nodes[node];\n            delete this.outgoingEdges[node];\n            delete this.incomingEdges[node];\n            [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n                Object.keys(edgeList).forEach(function (key) {\n                    var idx = edgeList[key].indexOf(node);\n                    if (idx >= 0) {\n                        edgeList[key].splice(idx, 1);\n                    }\n                }, this);\n            });\n        }\n    };\n    Graph.prototype.hasNode = function (node) {\n        return this.nodes.hasOwnProperty(node);\n    };\n    Graph.prototype.getNodeData = function (node) {\n        if (this.hasNode(node)) {\n            return this.nodes[node];\n        }\n        else {\n            throw new Error(\"Node does not exist: \" + node);\n        }\n    };\n    Graph.prototype.setNodeData = function (node, data) {\n        if (this.hasNode(node)) {\n            this.nodes[node] = data;\n        }\n        else {\n            throw new Error(\"Node does not exist: \" + node);\n        }\n    };\n    Graph.prototype.addDependency = function (from, to) {\n        if (!this.hasNode(from)) {\n            throw new Error(\"Node does not exist: \" + from);\n        }\n        if (!this.hasNode(to)) {\n            throw new Error(\"Node does not exist: \" + to);\n        }\n        if (this.outgoingEdges[from].indexOf(to) === -1) {\n            this.outgoingEdges[from].push(to);\n        }\n        if (this.incomingEdges[to].indexOf(from) === -1) {\n            this.incomingEdges[to].push(from);\n        }\n        return true;\n    };\n    Graph.prototype.removeDependency = function (from, to) {\n        var idx;\n        if (this.hasNode(from)) {\n            idx = this.outgoingEdges[from].indexOf(to);\n            if (idx >= 0) {\n                this.outgoingEdges[from].splice(idx, 1);\n            }\n        }\n        if (this.hasNode(to)) {\n            idx = this.incomingEdges[to].indexOf(from);\n            if (idx >= 0) {\n                this.incomingEdges[to].splice(idx, 1);\n            }\n        }\n    };\n    Graph.prototype.dependenciesOf = function (node, leavesOnly) {\n        if (this.hasNode(node)) {\n            var result = [];\n            var DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n            DFS(node);\n            var idx = result.indexOf(node);\n            if (idx >= 0) {\n                result.splice(idx, 1);\n            }\n            return result;\n        }\n        else {\n            throw new Error('Node does not exist: ' + containers_1.stringify(node));\n        }\n    };\n    Graph.prototype.dependantsOf = function (node, leavesOnly) {\n        if (this.hasNode(node)) {\n            var result = [];\n            var DFS = createDFS(this.incomingEdges, leavesOnly, result);\n            DFS(node);\n            var idx = result.indexOf(node);\n            if (idx >= 0) {\n                result.splice(idx, 1);\n            }\n            return result;\n        }\n        else {\n            throw new Error('Node does not exist: ' + containers_1.stringify(node));\n        }\n    };\n    Graph.prototype.overallOrder = function (leavesOnly) {\n        var self = this;\n        var result = [];\n        var keys = Object.keys(this.nodes);\n        if (keys.length === 0) {\n            return result; // Empty graph\n        }\n        else {\n            // Look for cycles - we run the DFS starting at all the nodes in case there\n            // are several disconnected subgraphs inside this dependency graph.\n            var CycleDFS = createDFS(this.outgoingEdges, false, []);\n            try {\n                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                    var nodeName = keys_1_1.value;\n                    CycleDFS(nodeName);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            var DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n            // Find all potential starting points (nodes with nothing depending on them) an\n            // run a DFS starting at these points to get the order\n            var nodeNames = keys.filter(function (nodeName) { return self.incomingEdges[nodeName].length === 0; });\n            try {\n                for (var nodeNames_1 = __values(nodeNames), nodeNames_1_1 = nodeNames_1.next(); !nodeNames_1_1.done; nodeNames_1_1 = nodeNames_1.next()) {\n                    var nodeName = nodeNames_1_1.value;\n                    DFS(nodeName);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (nodeNames_1_1 && !nodeNames_1_1.done && (_b = nodeNames_1.return)) _b.call(nodeNames_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            return result;\n        }\n        var e_1, _a, e_2, _b;\n    };\n    return Graph;\n}());\nexports.Graph = Graph;\nfunction createDFS(edges, leavesOnly, result) {\n    var currentPath = [];\n    var visited = {};\n    var DFS = function (currentNode) {\n        visited[currentNode] = true;\n        currentPath.push(currentNode);\n        try {\n            for (var _a = __values(edges[currentNode]), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var node = _b.value;\n                if (!visited[node]) {\n                    DFS(node);\n                }\n                else if (currentPath.indexOf(node) >= 0) {\n                    currentPath.push(node);\n                    throw new Error('Dependency Cycle Found: ' + currentPath.join(' -> '));\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        ;\n        currentPath.pop();\n        if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {\n            result.push(currentNode);\n        }\n        var e_3, _c;\n    };\n    return DFS;\n}\n//# sourceMappingURL=graph.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/graph.js?");

/***/ }),

/***/ "../typed-json-transform/lib/index.js":
/*!********************************************!*\
  !*** ../typed-json-transform/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n///<reference path=\"../@types/index.d.ts\" />\n__export(__webpack_require__(/*! ./graph */ \"../typed-json-transform/lib/graph.js\"));\n__export(__webpack_require__(/*! ./check */ \"../typed-json-transform/lib/check.js\"));\n__export(__webpack_require__(/*! ./olhm */ \"../typed-json-transform/lib/olhm.js\"));\n__export(__webpack_require__(/*! ./keypath */ \"../typed-json-transform/lib/keypath.js\"));\n__export(__webpack_require__(/*! ./cascade */ \"../typed-json-transform/lib/cascade.js\"));\n__export(__webpack_require__(/*! ./containers */ \"../typed-json-transform/lib/containers.js\"));\n__export(__webpack_require__(/*! ./mongo */ \"../typed-json-transform/lib/mongo.js\"));\n__export(__webpack_require__(/*! ./string */ \"../typed-json-transform/lib/string.js\"));\n__export(__webpack_require__(/*! ./merge */ \"../typed-json-transform/lib/merge.js\"));\n__export(__webpack_require__(/*! ./arrays */ \"../typed-json-transform/lib/arrays.js\"));\n__export(__webpack_require__(/*! ./map */ \"../typed-json-transform/lib/map.js\"));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/index.js?");

/***/ }),

/***/ "../typed-json-transform/lib/keypath.js":
/*!**********************************************!*\
  !*** ../typed-json-transform/lib/keypath.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar check_1 = __webpack_require__(/*! ./check */ \"../typed-json-transform/lib/check.js\");\nvar containers_1 = __webpack_require__(/*! ./containers */ \"../typed-json-transform/lib/containers.js\");\nvar arrays_1 = __webpack_require__(/*! ./arrays */ \"../typed-json-transform/lib/arrays.js\");\nfunction setValueForKeyPath(value, keyPath, input) {\n    var current = input;\n    var keys = keyPath.split('.');\n    for (var i = 0; i < keys.length - 1; i += 1) {\n        var thisKey = keys[i];\n        var nextKey = keys[i + 1];\n        if (nextKey) {\n            if (check_1.check(nextKey, Number)) {\n                if (Array.isArray(current)) {\n                    if (!Array.isArray(current[parseInt(thisKey, 10)])) {\n                        current[parseInt(thisKey, 10)] = [];\n                    }\n                }\n                else if (!Array.isArray(current[thisKey])) {\n                    current[thisKey] = [];\n                }\n            }\n            else if (Array.isArray(current)) {\n                if (!(current[parseInt(thisKey, 10)] !== null &&\n                    typeof current[parseInt(thisKey, 10)] === 'object')) {\n                    current[parseInt(thisKey, 10)] = {};\n                }\n            }\n            else if (!(current[thisKey] !== null &&\n                typeof current[thisKey] === 'object')) {\n                current[thisKey] = {};\n            }\n        }\n        if (Array.isArray(current)) {\n            current = current[parseInt(thisKey, 10)];\n        }\n        else {\n            current = current[thisKey];\n        }\n    }\n    var lastKey = keys[keys.length - 1];\n    if (Array.isArray(current)) {\n        current[parseInt(lastKey, 10)] = value;\n    }\n    else if (current !== null && typeof current === 'object') {\n        current[lastKey] = value;\n    }\n}\nexports.setValueForKeyPath = setValueForKeyPath;\nfunction mergeValueAtKeypath(value, keyPath, obj) {\n    // this function mutates obj\n    var existing = valueForKeyPath(keyPath, obj);\n    if (check_1.check(value, Object) && check_1.check(existing, Object)) {\n        containers_1.extend(existing, value);\n    }\n    else if (check_1.check(value, Array) && check_1.check(existing, Array)) {\n        setValueForKeyPath(arrays_1.union(existing, value), keyPath, obj);\n    }\n    else {\n        setValueForKeyPath(value, keyPath, obj);\n    }\n}\nexports.mergeValueAtKeypath = mergeValueAtKeypath;\nfunction valueForKeyPath(keyPath, input) {\n    if (!input) {\n        throw new Error('attempting to get valueForKeyPath on undefined object');\n    }\n    var current = input;\n    var keys = keyPath.split('.');\n    for (var i = 0; i < keys.length - 1; i += 1) {\n        var key = keys[i];\n        if (Array.isArray(current)) {\n            if (!current[parseInt(key, 10)]) {\n                return undefined;\n            }\n            current = current[parseInt(key, 10)];\n        }\n        else if (current !== null && typeof current === 'object') {\n            if (!current[key]) {\n                return undefined;\n            }\n            current = current[key];\n        }\n    }\n    var lastKey = keys[keys.length - 1];\n    if (Array.isArray(current)) {\n        return current[parseInt(lastKey, 10)];\n    }\n    return current[lastKey];\n}\nexports.valueForKeyPath = valueForKeyPath;\nfunction unsetKeyPath(keyPath, obj) {\n    // this function mutates obj\n    var keys = keyPath.split('.');\n    var current = obj;\n    for (var i = 0; i < keys.length - 1; i += 1) {\n        var key = keys[i];\n        if (Array.isArray(current)) {\n            if (!current[parseInt(key, 10)]) {\n                return false;\n            }\n            current = current[parseInt(key, 10)];\n        }\n        else if (current !== null && typeof current === 'object') {\n            if (!current[key]) {\n                return false;\n            }\n            current = current[key];\n        }\n    }\n    var lastKey = keys[keys.length - 1];\n    if (Array.isArray(current)) {\n        var index = parseInt(lastKey, 10);\n        if (current[index] !== undefined) {\n            delete current[index];\n            return true;\n        }\n        return false;\n    }\n    if (current[lastKey] !== undefined) {\n        delete current[lastKey];\n        return true;\n    }\n    return false;\n}\nexports.unsetKeyPath = unsetKeyPath;\nfunction _keyPathContainsPath(keyPath, ignorePath) {\n    var p = keyPath.split('.');\n    var t = ignorePath.split('.');\n    if (!(p.length > t.length)) {\n        return false;\n    }\n    for (var i = 0; i < t.length; i += 1) {\n        if (p[i] !== t[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports._keyPathContainsPath = _keyPathContainsPath;\nfunction keyPathContainsPath(keyPath, ignorePath) {\n    if (keyPath === ignorePath) {\n        return true;\n    }\n    return _keyPathContainsPath(keyPath, ignorePath);\n}\nexports.keyPathContainsPath = keyPathContainsPath;\nexports.lastKey = function (kp) {\n    var parts = kp.split('.');\n    if (parts.length) {\n        return parts[parts.length - 1];\n    }\n    return kp;\n};\nfunction filteredKeyPaths(_keyPaths, ignore) {\n    if (!ignore.length) {\n        return _keyPaths;\n    }\n    var toFilter = [];\n    try {\n        for (var ignore_1 = __values(ignore), ignore_1_1 = ignore_1.next(); !ignore_1_1.done; ignore_1_1 = ignore_1.next()) {\n            var ignorePath = ignore_1_1.value;\n            try {\n                for (var _keyPaths_1 = __values(_keyPaths), _keyPaths_1_1 = _keyPaths_1.next(); !_keyPaths_1_1.done; _keyPaths_1_1 = _keyPaths_1.next()) {\n                    var keyPath = _keyPaths_1_1.value;\n                    if (keyPathContainsPath(keyPath, ignorePath)) {\n                        toFilter.push(keyPath);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_keyPaths_1_1 && !_keyPaths_1_1.done && (_a = _keyPaths_1.return)) _a.call(_keyPaths_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (ignore_1_1 && !ignore_1_1.done && (_b = ignore_1.return)) _b.call(ignore_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return arrays_1.difference(_keyPaths, toFilter);\n    var e_2, _b, e_1, _a;\n}\nexports.filteredKeyPaths = filteredKeyPaths;\nfunction keyPaths(obj, _options, _stack, parent) {\n    var stack = _stack || [];\n    var options = containers_1.clone(_options || {});\n    var keys = Object.keys(obj);\n    if (keys.length > 0) {\n        try {\n            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                var el = keys_1_1.value;\n                var val = obj[el];\n                if (Array.isArray(val)) {\n                    if (options.diffArrays) {\n                        if (options.allLevels) {\n                            stack.push(parent ? parent + \".\" + el : el);\n                        }\n                        for (var i = 0; i < val.length; i += 1) {\n                            var p = parent ? parent + \".\" + el + \".\" + i : el + \".\" + i;\n                            var s = val[i];\n                            if (Array.isArray(s) || (s !== null && typeof s === 'object')) {\n                                if (options.allLevels) {\n                                    stack.push(p);\n                                }\n                                keyPaths(s, options, stack, p);\n                            }\n                            else {\n                                stack.push(p);\n                            }\n                        }\n                    }\n                    else {\n                        stack.push(parent ? parent + \".\" + el : el);\n                    }\n                }\n                else if (val instanceof Date) {\n                    var key = parent ? parent + \".\" + el : el;\n                    stack.push(key);\n                }\n                else if (val !== null && typeof val === 'object') {\n                    if (val instanceof Buffer || val instanceof RegExp) {\n                        stack.push(parent ? parent + \".\" + el : el);\n                    }\n                    else {\n                        if (options.allLevels) {\n                            stack.push(parent ? parent + \".\" + el : el);\n                        }\n                        keyPaths(val, options, stack, parent ? parent + \".\" + el : el);\n                    }\n                }\n                else {\n                    stack.push(parent ? parent + \".\" + el : el);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n    }\n    else {\n        stack.push(parent ? \"\" + parent : '');\n    }\n    return stack;\n    var e_3, _a;\n}\nexports.keyPaths = keyPaths;\nfunction allKeyPaths(obj, options) {\n    return keyPaths(obj, __assign({ allLevels: true, diffArrays: true }, options));\n}\nexports.allKeyPaths = allKeyPaths;\nfunction flatObject(object, options) {\n    var flat = {};\n    try {\n        for (var _a = __values(keyPaths(object, options)), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var keyPath = _b.value;\n            flat[keyPath] = valueForKeyPath(keyPath, object);\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    return flat;\n    var e_4, _c;\n}\nexports.flatObject = flatObject;\nexports.unflatten = function (source) {\n    var ret = {};\n    containers_1.each(source, function (val, keyPath) {\n        if (check_1.check(val, Number) || val) {\n            setValueForKeyPath(val, keyPath, ret);\n        }\n    });\n    return ret;\n};\n//# sourceMappingURL=keypath.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///../typed-json-transform/lib/keypath.js?");

/***/ }),

/***/ "../typed-json-transform/lib/map.js":
/*!******************************************!*\
  !*** ../typed-json-transform/lib/map.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar containers_1 = __webpack_require__(/*! ./containers */ \"../typed-json-transform/lib/containers.js\");\nexports.mapToObject = function (input) {\n    var out = {};\n    containers_1.each(input, function (value, key) {\n        if (typeof value == 'object') {\n            out[key] = exports.mapToObject(value);\n        }\n        else {\n            out[key] = value;\n        }\n    });\n    return out;\n};\n//# sourceMappingURL=map.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/map.js?");

/***/ }),

/***/ "../typed-json-transform/lib/merge.js":
/*!********************************************!*\
  !*** ../typed-json-transform/lib/merge.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar check_1 = __webpack_require__(/*! ./check */ \"../typed-json-transform/lib/check.js\");\nvar keypath_1 = __webpack_require__(/*! ./keypath */ \"../typed-json-transform/lib/keypath.js\");\nvar arrays_1 = __webpack_require__(/*! ./arrays */ \"../typed-json-transform/lib/arrays.js\");\nvar concat = arrays_1.Mutate.concat, subtract = arrays_1.Mutate.subtract, difference = arrays_1.Mutate.difference, intersect = arrays_1.Mutate.intersect, union = arrays_1.Mutate.union, xor = arrays_1.Mutate.xor, assign = arrays_1.Mutate.assign, compareAndFilter = arrays_1.Mutate.compareAndFilter;\nfunction _mergeArray(lhs, rhs, operator) {\n    switch (operator) {\n        case '=':\n            assign(lhs, rhs);\n            break;\n        case '+':\n            concat(lhs, rhs);\n            break;\n        case '-':\n            subtract(lhs, rhs);\n            break;\n        case '!':\n            difference(lhs, rhs);\n            break;\n        case '&':\n            intersect(lhs, rhs);\n            break;\n        case '|':\n            union(lhs, rhs);\n            break;\n        case '^':\n            xor(lhs, rhs);\n            break;\n        case '?':\n            compareAndFilter(lhs, rhs, function (a, b) { return a && b; });\n            break;\n        case '*':\n            compareAndFilter(lhs, rhs, function (a, b) { return b && a; });\n            break;\n        default: throw new Error(\"unhandled Array merge operator \" + operator);\n    }\n}\nfunction mergeArray(_a, rhs) {\n    var lhs = _a.data, state = _a.state;\n    var operator = state.merge.operator;\n    if (check_1.check(rhs, Object)) {\n        var mutated = void 0;\n        try {\n            for (var _b = __values(Object.keys(rhs)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var key = _c.value;\n                if ((key.length == 2) && (key[0] == '<')) {\n                    var nextState = __assign({}, state, { merge: {\n                            operator: key[1]\n                        } });\n                    mutated = true;\n                    mergeArray({ data: lhs, state: nextState }, rhs[key]).data;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (mutated) {\n            return { data: null, state: state };\n        }\n    }\n    else if (check_1.check(rhs, Array)) {\n        exports.recurArray({ data: null, state: state }, rhs);\n        _mergeArray(lhs, rhs, operator);\n        return { data: null, state: state };\n    }\n    switch (operator) {\n        case '=': throw new Error('replacing array value with non-array value');\n        default:\n            _mergeArray(lhs, arrays_1.arrayify(rhs), operator);\n            return { data: null, state: state };\n    }\n    var e_1, _d;\n}\nexports.mergeArray = mergeArray;\nfunction mergeObject(rv, _setter) {\n    var state = rv.state, data = rv.data;\n    var operator = state.merge.operator;\n    var setter = keypath_1.unflatten(_setter);\n    var _loop_1 = function (key) {\n        if ((key.length == 2) && (key[0] == '<')) {\n            var nextState = __assign({}, state, { merge: {\n                    operator: key[1]\n                } });\n            var assignment = mergeOrReturnAssignment({ data: data, state: nextState }, setter[key]).data;\n            if (assignment || check_1.check(assignment, [Number])) {\n                data[key] = assignment;\n            }\n        }\n        else {\n            var lhs_1 = data[key];\n            var rhs_1 = setter[key];\n            var doMerge = function () {\n                var assignment = mergeOrReturnAssignment({ data: lhs_1, state: state }, rhs_1).data;\n                if (assignment || check_1.check(assignment, [Number])) {\n                    if (operator == '^') {\n                        if (data[key] == assignment)\n                            delete data[key];\n                        else\n                            data[key] = assignment;\n                    }\n                    else {\n                        data[key] = assignment;\n                    }\n                }\n            };\n            switch (operator) {\n                case '^':\n                case '|':\n                case '+':\n                    doMerge();\n                    break;\n                case '=':\n                    doMerge();\n                    break;\n                case '!':\n                    if (!lhs_1)\n                        doMerge();\n                    break;\n                case '?':\n                case '&':\n                case '*':\n                    if (lhs_1)\n                        doMerge();\n                    break;\n                case '-':\n                    if (rhs_1)\n                        delete data[key];\n                    break;\n                default: throw new Error(\"unhandled merge operator \" + operator);\n            }\n            if (check_1.check(data, Object)) {\n                try {\n                    for (var _a = __values(Object.keys(data)), _b = _a.next(); !_b.done; _b = _a.next()) {\n                        var key_1 = _b.value;\n                        var rhs_2 = setter[key_1];\n                        switch (operator) {\n                            case '=':\n                                if (!rhs_2)\n                                    delete data[key_1];\n                                break;\n                            case '&':\n                            case '*':\n                                if (!rhs_2)\n                                    delete data[key_1];\n                                break;\n                            default: break;\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        var e_2, _c;\n    };\n    try {\n        for (var _a = __values(Object.keys(setter)), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var key = _b.value;\n            _loop_1(key);\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return { data: data, state: state };\n    var e_3, _c;\n}\nexports.mergeObject = mergeObject;\nvar printType = function (val) {\n    if (check_1.check(val, Object)) {\n        return 'object';\n    }\n    return val;\n};\nfunction throwIfImplicitConversion(rv, rhs) {\n    var lhs = rv.data, state = rv.state;\n    var operator = state.merge.operator;\n    if (lhs && (typeof lhs != typeof rhs) && state.implicitTypeConversionError) {\n        throw new Error(\"implicit type change in \" + printType(lhs) + \" \" + operator + \" \" + printType(rhs) + \"\\n\" + JSON.stringify(rhs, null, 2));\n    }\n}\nexports.recurArray = function (rv, rhs) {\n    var state = rv.state;\n    rhs.forEach(function (val, index) {\n        var res = mergeOrReturnAssignment({ data: null, state: __assign({}, state, { merge: { operator: '=' } }) }, val).data;\n        if (res || check_1.check(res, Number)) {\n            rhs[index] = res;\n        }\n    });\n};\nfunction mergeOrReturnAssignment(rv, rhs) {\n    var lhs = rv.data, state = rv.state;\n    var operator = state.merge.operator;\n    if (check_1.check(lhs, Array)) {\n        mergeArray(rv, rhs);\n    }\n    else if (check_1.check(lhs, Object)) {\n        if (check_1.check(rhs, Object)) {\n            mergeObject(rv, rhs);\n        }\n        else {\n            if (arrays_1.contains(['&', '*', '-'], operator)) {\n                switch (operator) {\n                    case '*':\n                    case '&': if (!rhs)\n                        return { data: 0, state: state };\n                    case '-':\n                        if (rhs && check_1.check(rhs, String))\n                            delete lhs[rhs];\n                        return { data: null, state: state };\n                }\n            }\n            throwIfImplicitConversion(rv, rhs);\n        }\n    }\n    else {\n        if (check_1.check(rhs, Object)) {\n            if (exports.isMergeConstructor(rhs)) {\n                var obj = construct(rv, rhs).data;\n                return mergeOrReturnAssignment(rv, obj);\n            }\n            else {\n                throwIfImplicitConversion(rv, rhs);\n                var ret = { data: {}, state: __assign({}, state, { merge: { operator: '=' } }) };\n                mergeOrReturnAssignment(ret, rhs);\n                return ret;\n            }\n        }\n        if (check_1.check(rhs, Array)) {\n            throwIfImplicitConversion(rv, rhs);\n            exports.recurArray(rv, rhs);\n        }\n        return { data: rhs, state: state };\n    }\n    return { data: null, state: state };\n}\nexports.mergeOrReturnAssignment = mergeOrReturnAssignment;\nexports.isMergeConstructor = function (val) {\n    try {\n        for (var _a = __values(Object.keys(val)), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var key = _b.value;\n            if ((key.length == 2) && (key[0] == '<')) {\n                return true;\n            }\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    var e_4, _c;\n};\nfunction construct(rv, constructor) {\n    var data;\n    var state = rv.state;\n    try {\n        for (var _a = __values(Object.keys(constructor)), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var key = _b.value;\n            if ((key.length == 2) && (key[0] == '<')) {\n                var nextOperator = key[1];\n                var res = mergeOrReturnAssignment({\n                    data: data, state: {\n                        merge: __assign({}, state.merge, { operator: nextOperator })\n                    }\n                }, constructor[key]).data;\n                if (res || check_1.check(res, Number)) {\n                    data = res;\n                }\n            }\n        }\n    }\n    catch (e_5_1) { e_5 = { error: e_5_1 }; }\n    finally {\n        try {\n            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        }\n        finally { if (e_5) throw e_5.error; }\n    }\n    return { data: data, state: state };\n    var e_5, _c;\n}\nexports.construct = construct;\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/merge.js?");

/***/ }),

/***/ "../typed-json-transform/lib/mongo.js":
/*!********************************************!*\
  !*** ../typed-json-transform/lib/mongo.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar check_1 = __webpack_require__(/*! ./check */ \"../typed-json-transform/lib/check.js\");\nvar arrays_1 = __webpack_require__(/*! ./arrays */ \"../typed-json-transform/lib/arrays.js\");\nvar containers_1 = __webpack_require__(/*! ./containers */ \"../typed-json-transform/lib/containers.js\");\nvar keypath_1 = __webpack_require__(/*! ./keypath */ \"../typed-json-transform/lib/keypath.js\");\nfunction shouldSet(val, prev) {\n    if (Array.isArray(val)) {\n        return !check_1.isEqual(prev, val);\n    }\n    else if (val instanceof Date) {\n        if (prev instanceof Date) {\n            return (val.getTime() !== prev.getTime());\n        }\n        return !!val.getTime();\n    }\n    else if (check_1.check(val, Number)) {\n        return (prev !== val) || !check_1.check(prev, Number);\n    }\n    else if (val !== null && typeof val === 'object') {\n        return !check_1.isEqual(prev, val);\n    }\n    else if (val) {\n        return prev !== val;\n    }\n}\nfunction shouldUnset(val, prev) {\n    if (prev instanceof Date) {\n        return !(val && val.getTime());\n    }\n    if ((prev || check_1.check(prev, Number)) && !(val || check_1.check(val, Number))) {\n        return true;\n    }\n    if (val && typeof val === 'object') {\n        if (!Object.keys(val).length) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction diffToModifier(prev, doc, fieldsToIgnore, pruneEmptyObjects) {\n    var delta = { $set: {}, $unset: {} };\n    if (doc) {\n        var forwardKeyPaths = keypath_1.filteredKeyPaths(keypath_1.keyPaths(doc), fieldsToIgnore || []);\n        try {\n            for (var forwardKeyPaths_1 = __values(forwardKeyPaths), forwardKeyPaths_1_1 = forwardKeyPaths_1.next(); !forwardKeyPaths_1_1.done; forwardKeyPaths_1_1 = forwardKeyPaths_1.next()) {\n                var keyPath = forwardKeyPaths_1_1.value;\n                var val = keypath_1.valueForKeyPath(keyPath, doc);\n                if (shouldSet(val, keypath_1.valueForKeyPath(keyPath, prev))) {\n                    delta.$set[keyPath] = val;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (forwardKeyPaths_1_1 && !forwardKeyPaths_1_1.done && (_a = forwardKeyPaths_1.return)) _a.call(forwardKeyPaths_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    if (prev) {\n        var kps = keypath_1.keyPaths(prev, { allLevels: true });\n        var existingKeyPaths = keypath_1.filteredKeyPaths(kps, fieldsToIgnore || []);\n        try {\n            for (var existingKeyPaths_1 = __values(existingKeyPaths), existingKeyPaths_1_1 = existingKeyPaths_1.next(); !existingKeyPaths_1_1.done; existingKeyPaths_1_1 = existingKeyPaths_1.next()) {\n                var keyPath = existingKeyPaths_1_1.value;\n                var curVal = keypath_1.valueForKeyPath(keyPath, doc);\n                if (shouldUnset(curVal, keypath_1.valueForKeyPath(keyPath, prev))) {\n                    delta.$unset[keyPath] = true;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (existingKeyPaths_1_1 && !existingKeyPaths_1_1.done && (_b = existingKeyPaths_1.return)) _b.call(existingKeyPaths_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        var modifier = delta.$unset;\n        var keys = Object.keys(modifier);\n        try {\n            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                var pathA = keys_1_1.value;\n                try {\n                    for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {\n                        var pathB = keys_2_1.value;\n                        if (keypath_1._keyPathContainsPath(pathA, pathB)) {\n                            delete modifier[pathA];\n                        }\n                    }\n                }\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                finally {\n                    try {\n                        if (keys_2_1 && !keys_2_1.done && (_c = keys_2.return)) _c.call(keys_2);\n                    }\n                    finally { if (e_3) throw e_3.error; }\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (keys_1_1 && !keys_1_1.done && (_d = keys_1.return)) _d.call(keys_1);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n    }\n    if (!Object.keys(delta.$set).length) {\n        delete delta.$set;\n    }\n    if (!Object.keys(delta.$unset).length) {\n        delete delta.$unset;\n    }\n    if (Object.keys(delta).length) {\n        if (pruneEmptyObjects) {\n            var newDelta = diffToModifier(prev, apply(containers_1.clone(prev), delta), fieldsToIgnore, false);\n            return newDelta || delta;\n        }\n        return delta;\n    }\n    var e_1, _a, e_2, _b, e_4, _d, e_3, _c;\n}\nexports.diffToModifier = diffToModifier;\nfunction modifierToObj(modifier) {\n    if (modifier) {\n        var obj = {};\n        try {\n            for (var _a = __values(Object.keys(modifier.$set || {})), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var keyPath = _b.value;\n                var val = modifier.$set[keyPath];\n                keypath_1.setValueForKeyPath(val, keyPath, obj);\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        try {\n            for (var _d = __values(Object.keys(modifier.$unset || {})), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var keyPath = _e.value;\n                keypath_1.setValueForKeyPath(undefined, keyPath, obj);\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n        return obj;\n    }\n    var e_5, _c, e_6, _f;\n}\nexports.modifierToObj = modifierToObj;\nfunction objToModifier(obj) {\n    return diffToModifier(null, obj);\n}\nexports.objToModifier = objToModifier;\nfunction apply(dest, source) {\n    if (!source) {\n        return dest;\n    }\n    if (source.$set || source.$unset) {\n        $set(dest, source);\n        $unset(dest, source);\n    }\n    else {\n        var mod = objToModifier(source);\n        $set(dest, mod);\n        $unset(dest, mod);\n    }\n    return containers_1.prune(dest);\n}\nexports.apply = apply;\nfunction $set(dest, source) {\n    if (!source) {\n        return;\n    }\n    if (source.$set || source.$unset) {\n        $set(dest, source.$set);\n    }\n    return containers_1.each(source, function (val, keyPath) {\n        if (check_1.check(val, Number) || val) {\n            keypath_1.setValueForKeyPath(val, keyPath, dest);\n        }\n    });\n}\nexports.$set = $set;\nfunction $addToSet(dest, src) {\n    if (!Array.isArray(dest)) {\n        throw new Error('$addToSet, 1st arg not array');\n    }\n    if (!arrays_1.contains(dest, src)) {\n        dest.push(src);\n    }\n    return dest;\n}\nexports.$addToSet = $addToSet;\nfunction $unset(dest, source) {\n    if (!source) {\n        return;\n    }\n    if (source.$unset || source.$set) {\n        $unset(dest, source.$unset);\n    }\n    containers_1.each(source, function (val, keyPath) { keypath_1.unsetKeyPath(keyPath, dest); });\n}\nexports.$unset = $unset;\nfunction update(doc, options) {\n    var model;\n    if (check_1.check(options.get, Function)) {\n        model = options.get();\n    }\n    else if (doc._id && options.collection) {\n        model = options.collection.findOne({ _id: doc._id });\n    }\n    if (!model) {\n        throw new Error('Diff: no doc to diff against');\n    }\n    var diff = diffToModifier(model, doc, options.ignore);\n    if (diff) {\n        if (!options.set && !options.collection) {\n            throw new Error('Diff: no setter provided');\n        }\n        if (check_1.check(options.set, Function)) {\n            var copy = containers_1.clone(model);\n            apply(copy, diff);\n            options.set(copy);\n            if (!check_1.isEqual(copy, model)) {\n                throw new Error('Diff: not equal after update');\n            }\n        }\n        else if (options.collection) {\n            options.collection.update({ _id: model._id }, { $set: diff });\n        }\n    }\n    return diff;\n}\nexports.update = update;\nfunction mapModifierToKey(modifier, key) {\n    if (!modifier) {\n        throw new Error('called mapModifierToKey on undefined');\n    }\n    var valueModifier = {};\n    try {\n        for (var _a = __values(Object.keys(modifier.$set || {})), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var keyPath = _b.value;\n            if (valueModifier.$set == null) {\n                valueModifier.$set = {};\n            }\n            valueModifier.$set[key + \".\" + keyPath] = modifier.$set[keyPath];\n        }\n    }\n    catch (e_7_1) { e_7 = { error: e_7_1 }; }\n    finally {\n        try {\n            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        }\n        finally { if (e_7) throw e_7.error; }\n    }\n    try {\n        for (var _d = __values(Object.keys(modifier.$unset || {})), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var keyPath = _e.value;\n            if (valueModifier.$unset == null) {\n                valueModifier.$unset = {};\n            }\n            valueModifier.$unset[key + \".\" + keyPath] = modifier.$set[keyPath];\n        }\n    }\n    catch (e_8_1) { e_8 = { error: e_8_1 }; }\n    finally {\n        try {\n            if (_e && !_e.done && (_f = _d.return)) _f.call(_d);\n        }\n        finally { if (e_8) throw e_8.error; }\n    }\n    return valueModifier;\n    var e_7, _c, e_8, _f;\n}\nexports.mapModifierToKey = mapModifierToKey;\n//# sourceMappingURL=mongo.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/mongo.js?");

/***/ }),

/***/ "../typed-json-transform/lib/olhm.js":
/*!*******************************************!*\
  !*** ../typed-json-transform/lib/olhm.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar check_1 = __webpack_require__(/*! ./check */ \"../typed-json-transform/lib/check.js\");\nvar arrays_1 = __webpack_require__(/*! ./arrays */ \"../typed-json-transform/lib/arrays.js\");\nvar graph_1 = __webpack_require__(/*! ./graph */ \"../typed-json-transform/lib/graph.js\");\nvar OLHV = /** @class */ (function () {\n    function OLHV() {\n    }\n    return OLHV;\n}());\nexports.OLHV = OLHV;\nvar OLHM = /** @class */ (function () {\n    function OLHM() {\n    }\n    return OLHM;\n}());\nexports.OLHM = OLHM;\n(function (OLHM) {\n    function parse(object) {\n        var map = new OLHM();\n        try {\n            for (var _a = __values(Object.keys(object)), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var k = _b.value;\n                if (OLHV.is(object(k))) {\n                    map[k] = object[k];\n                }\n                else {\n                    map[k] = {\n                        value: object[k]\n                    };\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return map;\n        var e_1, _c;\n    }\n    OLHM.parse = parse;\n    function safe(olhm) {\n        if (!olhm)\n            return [];\n        if (!check_1.check(olhm, Object)) {\n            throw new Error('OLHM expects an object as input');\n        }\n        var keys = Object.keys(olhm);\n        if (keys.length === 0) {\n            return [];\n        }\n        // single key optimization\n        if (keys.length === 1) {\n            return [OLHV.safe(olhm[keys[0]])];\n        }\n        // 2 or more keys, scan for dependencies\n        var graph = new graph_1.Graph();\n        try {\n            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                var k = keys_1_1.value;\n                graph.addNode(k);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        try {\n            for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {\n                var k = keys_2_1.value;\n                if (OLHV.is(olhm[k])) {\n                    graph.addDependency(k, olhm[k].require);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (keys_2_1 && !keys_2_1.done && (_b = keys_2.return)) _b.call(keys_2);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        // order based on dependencies\n        var final = [];\n        try {\n            for (var _c = __values(graph.overallOrder()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var k = _d.value;\n                final.push(OLHV.safe(olhm[k]));\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_e = _c.return)) _e.call(_c);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        return final;\n        var e_2, _a, e_3, _b, e_4, _e;\n    }\n    OLHM.safe = safe;\n    function okmap(olhm, fn) {\n        if (!check_1.check(olhm, Object)) {\n            throw new Error('OLHM expects an object as input');\n        }\n        var keys = Object.keys(olhm);\n        if (keys.length === 0) {\n            return {};\n        }\n        var final = {};\n        try {\n            for (var keys_3 = __values(keys), keys_3_1 = keys_3.next(); !keys_3_1.done; keys_3_1 = keys_3.next()) {\n                var k = keys_3_1.value;\n                var olhv = olhm[k];\n                if (OLHV.is(olhv)) {\n                    var ret = fn(olhv.value, k);\n                    if (OLHV.is(ret)) {\n                        final[k] = ret;\n                    }\n                    else {\n                        final[k] = {\n                            value: ret,\n                            require: olhv.require\n                        };\n                    }\n                }\n                else {\n                    final[k] = fn(olhv, k);\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (keys_3_1 && !keys_3_1.done && (_a = keys_3.return)) _a.call(keys_3);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        return final;\n        var e_5, _a;\n    }\n    OLHM.okmap = okmap;\n    function map(olhm, fn) {\n        if (!olhm)\n            return [];\n        if (!check_1.check(olhm, Object)) {\n            throw new Error('OLHM expects an object as input');\n        }\n        var keys = Object.keys(olhm);\n        if (keys.length === 0) {\n            return [];\n        }\n        // single key optimization\n        if (keys.length === 1) {\n            return [fn(OLHV.safe(olhm[keys[0]]), keys[0])];\n        }\n        // 2 or more keys, scan for dependencies\n        var graph = new graph_1.Graph();\n        try {\n            for (var keys_4 = __values(keys), keys_4_1 = keys_4.next(); !keys_4_1.done; keys_4_1 = keys_4.next()) {\n                var k = keys_4_1.value;\n                graph.addNode(k);\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (keys_4_1 && !keys_4_1.done && (_a = keys_4.return)) _a.call(keys_4);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n        try {\n            for (var keys_5 = __values(keys), keys_5_1 = keys_5.next(); !keys_5_1.done; keys_5_1 = keys_5.next()) {\n                var k = keys_5_1.value;\n                if (OLHV.is(olhm[k])) {\n                    graph.addDependency(k, olhm[k].require);\n                }\n            }\n        }\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\n        finally {\n            try {\n                if (keys_5_1 && !keys_5_1.done && (_b = keys_5.return)) _b.call(keys_5);\n            }\n            finally { if (e_7) throw e_7.error; }\n        }\n        // order based on dependencies\n        var final = [];\n        try {\n            for (var _c = __values(graph.overallOrder()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var k = _d.value;\n                var res = fn(OLHV.safe(olhm[k]), k);\n                final.push(res);\n            }\n        }\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_e = _c.return)) _e.call(_c);\n            }\n            finally { if (e_8) throw e_8.error; }\n        }\n        return final;\n        var e_6, _a, e_7, _b, e_8, _e;\n    }\n    OLHM.map = map;\n    function reduce(olhm, fn, iv) {\n        var iterable = safe(olhm);\n        var i = 0;\n        try {\n            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {\n                var v = iterable_1_1.value;\n                iv = fn(iv, v, i);\n                i++;\n            }\n        }\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);\n            }\n            finally { if (e_9) throw e_9.error; }\n        }\n        return iv;\n        var e_9, _a;\n    }\n    OLHM.reduce = reduce;\n})(OLHM = exports.OLHM || (exports.OLHM = {}));\nexports.OLHM = OLHM;\n(function (OLHV) {\n    function is(obj) {\n        if (check_1.check(obj, Object)) {\n            var keys = Object.keys(obj);\n            return keys.length === 2 && arrays_1.containsAll(keys, ['require', 'value']);\n        }\n        return false;\n    }\n    OLHV.is = is;\n    function safe(objOrVal) {\n        if (is(objOrVal)) {\n            return objOrVal.value;\n        }\n        return objOrVal;\n    }\n    OLHV.safe = safe;\n})(OLHV = exports.OLHV || (exports.OLHV = {}));\nexports.OLHV = OLHV;\n//# sourceMappingURL=olhm.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/olhm.js?");

/***/ }),

/***/ "../typed-json-transform/lib/string.js":
/*!*********************************************!*\
  !*** ../typed-json-transform/lib/string.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar containers_1 = __webpack_require__(/*! ./containers */ \"../typed-json-transform/lib/containers.js\");\nexports.startsWith = function (string, s) {\n    return string.slice(0, s.length) === s;\n};\nexports.beginsWith = function (string, s) {\n    return string.slice(0, s.length) === s;\n};\nexports.endsWith = function (string, s) {\n    return s === string.slice(-s.length);\n};\nexports.replaceAll = function (str, find, rep) {\n    var escaped = find.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    return str.replace(new RegExp(escaped, 'g'), rep);\n};\nexports.trim = function (str) {\n    var ret = str;\n    while (ret.length && ret[ret.length - 1] == ' ') {\n        ret = ret.slice(0, ret.length - 1);\n    }\n    while (ret.length && ret[0] == ' ') {\n        ret = ret.slice(1, ret.length);\n    }\n    return ret;\n};\nvar toCamelDefaults = {};\nexports.toCamel = function (input, options) {\n    var _a = __assign({}, toCamelDefaults, options), delimiter = _a.delimiter, upperCase = _a.upperCase;\n    var res = containers_1.map(input.split(delimiter || \" \"), function (word) {\n        return word.charAt(0).toUpperCase() + word.slice(1);\n    }).join('');\n    if (upperCase)\n        return res;\n    return res.charAt(0).toLowerCase() + res.slice(1);\n};\nvar fromCamelDefaults = {\n    upperCase: true\n};\nexports.fromCamel = function (input, options) {\n    var _a = __assign({}, fromCamelDefaults, options), delimiter = _a.delimiter, upperCase = _a.upperCase, capitalize = _a.capitalize, capsLock = _a.capsLock;\n    var words = input.match(/[A-Za-z][a-z]*/g);\n    var out = words;\n    out = out.map(function (word) {\n        var firstLetter = word.charAt(0);\n        return (capitalize || capsLock ? firstLetter.toUpperCase() : firstLetter.toLowerCase()) + (capsLock ? word.substring(1).toUpperCase() : word.substring(1));\n    });\n    var joined = out.join(delimiter || \" \");\n    if (upperCase) {\n        return joined.charAt(0)\n            .toUpperCase() + joined.substring(1);\n    }\n    return joined;\n};\n//# sourceMappingURL=string.js.map\n\n//# sourceURL=webpack:///../typed-json-transform/lib/string.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: parse, load, MonacoTokensProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"load\", function() { return load; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MonacoTokensProvider\", function() { return MonacoTokensProvider; });\n/* harmony import */ var nearley__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nearley */ \"../../node_modules/nearley/lib/nearley.js\");\n/* harmony import */ var nearley__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nearley__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst grammar = __webpack_require__(/*! ./nearley */ \"./src/nearley/index.ts\");\n\nconst parse = text => {\n  const parser = new nearley__WEBPACK_IMPORTED_MODULE_0__[\"Parser\"](nearley__WEBPACK_IMPORTED_MODULE_0__[\"Grammar\"].fromCompiled(grammar));\n  return parser.feed(text);\n};\nconst load = text => {\n  const parsed = parse(text);\n  return parsed.results[0];\n};\n\nclass ParserState {\n  clone() {\n    return this;\n  }\n\n  equals() {\n    return true;\n  }\n\n}\n\nclass MonacoTokensProvider {\n  constructor() {\n    this.parser = void 0;\n  }\n\n  getInitialState(line) {\n    this.parser = new nearley__WEBPACK_IMPORTED_MODULE_0__[\"Parser\"](nearley__WEBPACK_IMPORTED_MODULE_0__[\"Grammar\"].fromCompiled(grammar));\n    return new ParserState();\n  }\n\n  tokenize(line, state) {\n    // console.log(state);\n    // console.log('tokenize', line, state)\n    const {\n      results,\n      lexer\n    } = this.parser.feed(line);\n    console.log(lexer);\n    return {\n      endState: state,\n      tokens: results[0]\n    };\n  }\n\n}\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/nearley/index.ts":
/*!******************************!*\
  !*** ./src/nearley/index.ts ***!
  \******************************/
/*! exports provided: Lexer, ParserRules, ParserStart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return Lexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParserRules\", function() { return ParserRules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParserStart\", function() { return ParserStart; });\n/* harmony import */ var typed_json_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typed-json-transform */ \"../typed-json-transform/lib/index.js\");\n/* harmony import */ var typed_json_transform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(typed_json_transform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lexer */ \"./src/nearley/lexer.ts\");\n/* harmony import */ var _post_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./post/errors */ \"./src/nearley/post/errors.ts\");\n/* harmony import */ var _post_ast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./post/ast */ \"./src/nearley/post/ast.ts\");\n// Generated automatically by nearley, version 2.16.0\n// http://github.com/Hardmath123/nearley\n// Bypasses TS6133. Allow declared but unused functions.\n// @ts-ignore\nfunction id(d) {\n  return d[0];\n}\n\n\n\n\n\n;\n;\n;\nvar Lexer = _lexer__WEBPACK_IMPORTED_MODULE_1__[\"lexer\"];\nvar ParserRules = [{\n  \"name\": \"uri\",\n  \"symbols\": [\"url\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"uri\",\n  \"symbols\": [\"authority\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"url\",\n  \"symbols\": [\"urlDomainScheme\", \"authority\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"url\",\n  \"symbols\": [\"urlScheme\", \"uriPathComponent\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"url\",\n  \"symbols\": [\"urlScheme\", \"urlPath\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlDomainScheme\",\n  \"symbols\": [\"urlScheme\", {\n    \"literal\": \"/\"\n  }, {\n    \"literal\": \"/\"\n  }],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlSchemes\",\n  \"symbols\": [\"urlSchemes\", \"urlScheme\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlSchemes\",\n  \"symbols\": [\"urlScheme\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"urlScheme\",\n  \"symbols\": [\"domainComponent\", {\n    \"literal\": \":\"\n  }],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"authority\",\n  \"symbols\": [\"urlCredentials\", {\n    \"literal\": \"@\"\n  }, \"_authority\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"authority\",\n  \"symbols\": [\"_authority\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"_authority$ebnf$1\",\n  \"symbols\": [\"uriPathComponent\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"_authority$ebnf$1\",\n  \"symbols\": [],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"_authority$ebnf$2\",\n  \"symbols\": [\"uriQueries\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"_authority$ebnf$2\",\n  \"symbols\": [],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"_authority$ebnf$3\",\n  \"symbols\": [\"uriFragment\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"_authority$ebnf$3\",\n  \"symbols\": [],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"_authority\",\n  \"symbols\": [\"uriDomainComponent\", \"_authority$ebnf$1\", \"_authority$ebnf$2\", \"_authority$ebnf$3\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"uriQueries\",\n  \"symbols\": [\"uriQueries\", \"uriQuery\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"uriQueries\",\n  \"symbols\": [\"uriQuery\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"uriPathComponent\",\n  \"symbols\": [{\n    \"literal\": \"/\"\n  }, \"urlPath\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"uriPathComponent\",\n  \"symbols\": [{\n    \"literal\": \"/\"\n  }],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"urlCredentials\",\n  \"symbols\": [\"urlCredentials\", {\n    \"literal\": \":\"\n  }, \"password\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlCredentials\",\n  \"symbols\": [\"email\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"urlCredentials\",\n  \"symbols\": [\"subdomain\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"urlPath\",\n  \"symbols\": [\"urlPath\", {\n    \"literal\": \"/\"\n  }, \"urlPathName\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlPath\",\n  \"symbols\": [\"urlPath\", {\n    \"literal\": \"/\"\n  }],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlPath\",\n  \"symbols\": [\"urlPathName\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"urlPathName\",\n  \"symbols\": [\"urlPathName\", {\n    \"literal\": \".\"\n  }, \"urlPathWord\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlPathName\",\n  \"symbols\": [\"urlPathWord\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"urlPathWord\",\n  \"symbols\": [\"urlPathWord\", \"urlPathChar\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlPathWord\",\n  \"symbols\": [\"urlPathChar\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"urlPathChar\",\n  \"symbols\": [/[^ ^\\/^.^?^;]/],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"filePath\",\n  \"symbols\": [\"filePath\", {\n    \"literal\": \"/\"\n  }, \"fileName\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"filePath\",\n  \"symbols\": [\"fileName\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"fileName\",\n  \"symbols\": [\"fileName\", {\n    \"literal\": \".\"\n  }, \"fileWord\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"fileName\",\n  \"symbols\": [\"fileWord\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"fileWord\",\n  \"symbols\": [\"fileWord\", \"fileChar\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"fileWord\",\n  \"symbols\": [\"fileChar\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"fileChar\",\n  \"symbols\": [/[^ ^\\/^.]/],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"password\",\n  \"symbols\": [\"urlSafePlusEncoded\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"email\",\n  \"symbols\": [\"subdomain\", {\n    \"literal\": \"@\"\n  }, \"domain\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"uriDomainComponent\",\n  \"symbols\": [\"uriDomainComponent\", \"uriPortComponent\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"uriDomainComponent\",\n  \"symbols\": [\"domain\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"uriDomainComponent\",\n  \"symbols\": [{\n    \"literal\": \"[\"\n  }, \"ipv6\", {\n    \"literal\": \"]\"\n  }],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"uriDomainComponent\",\n  \"symbols\": [\"ipv4\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"ipv6$macrocall$2\",\n  \"symbols\": [\"ipv6Group\"]\n}, {\n  \"name\": \"ipv6$macrocall$1\",\n  \"symbols\": [\"ipv6$macrocall$2\", \"ipv6$macrocall$2\", \"ipv6$macrocall$2\", \"ipv6$macrocall$2\", \"ipv6$macrocall$2\", \"ipv6$macrocall$2\", \"ipv6$macrocall$2\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6\",\n  \"symbols\": [\"ipv6$macrocall$1\", \"ipv6Number\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6$macrocall$4\",\n  \"symbols\": [\"ipv6Group\"]\n}, {\n  \"name\": \"ipv6$macrocall$3\",\n  \"symbols\": [\"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6$macrocall$3\",\n  \"symbols\": [\"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6$macrocall$3\",\n  \"symbols\": [\"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6$macrocall$3\",\n  \"symbols\": [\"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6$macrocall$3\",\n  \"symbols\": [\"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6$macrocall$3\",\n  \"symbols\": [\"ipv6$macrocall$4\", \"ipv6$macrocall$4\", \"ipv6$macrocall$4\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6$macrocall$3\",\n  \"symbols\": [\"ipv6$macrocall$4\", \"ipv6$macrocall$4\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6$macrocall$3\",\n  \"symbols\": [\"ipv6$macrocall$4\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6\",\n  \"symbols\": [\"ipv6$macrocall$3\", {\n    \"literal\": \":\"\n  }, \"ipv6Number\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6Group\",\n  \"symbols\": [\"ipv6Number\", {\n    \"literal\": \":\"\n  }],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6Number$macrocall$2\",\n  \"symbols\": [\"hexDigit\"]\n}, {\n  \"name\": \"ipv6Number$macrocall$1\",\n  \"symbols\": [\"ipv6Number$macrocall$2\", \"ipv6Number$macrocall$2\", \"ipv6Number$macrocall$2\", \"ipv6Number$macrocall$2\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6Number$macrocall$1\",\n  \"symbols\": [\"ipv6Number$macrocall$2\", \"ipv6Number$macrocall$2\", \"ipv6Number$macrocall$2\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6Number$macrocall$1\",\n  \"symbols\": [\"ipv6Number$macrocall$2\", \"ipv6Number$macrocall$2\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6Number$macrocall$1\",\n  \"symbols\": [\"ipv6Number$macrocall$2\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv6Number\",\n  \"symbols\": [\"ipv6Number$macrocall$1\"]\n}, {\n  \"name\": \"ipv4\",\n  \"symbols\": [\"ipv4Group\", {\n    \"literal\": \".\"\n  }, \"ipv4Group\", {\n    \"literal\": \".\"\n  }, \"ipv4Group\", {\n    \"literal\": \".\"\n  }, \"ipv4Group\"]\n}, {\n  \"name\": \"ipv4Group\",\n  \"symbols\": [\"d2\", \"d5\", \"d0_5\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv4Group\",\n  \"symbols\": [\"d2\", \"d0_4\", \"d0_9\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv4Group\",\n  \"symbols\": [\"d1\", \"d0_9\", \"d0_9\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv4Group\",\n  \"symbols\": [\"d0_9\", \"d0_9\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"ipv4Group\",\n  \"symbols\": [\"d0_9\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"d1\",\n  \"symbols\": [{\n    \"literal\": \"1\"\n  }],\n  \"postprocess\": ([tok]) => tok\n}, {\n  \"name\": \"d2\",\n  \"symbols\": [{\n    \"literal\": \"2\"\n  }],\n  \"postprocess\": ([tok]) => tok\n}, {\n  \"name\": \"d5\",\n  \"symbols\": [{\n    \"literal\": \"5\"\n  }],\n  \"postprocess\": ([tok]) => tok\n}, {\n  \"name\": \"d0_4\",\n  \"symbols\": [/[0-4]/],\n  \"postprocess\": ([tok]) => tok\n}, {\n  \"name\": \"d0_5\",\n  \"symbols\": [/[0-5]/],\n  \"postprocess\": ([tok]) => tok\n}, {\n  \"name\": \"d0_9\",\n  \"symbols\": [/[0-9]/],\n  \"postprocess\": ([tok]) => tok\n}, {\n  \"name\": \"domain\",\n  \"symbols\": [\"subdomain\", {\n    \"literal\": \".\"\n  }, \"domainComponent\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"uriPortComponent\",\n  \"symbols\": [{\n    \"literal\": \":\"\n  }, \"number\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"subdomain\",\n  \"symbols\": [\"domainComponent\", {\n    \"literal\": \".\"\n  }, \"subdomain\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"subdomain\",\n  \"symbols\": [\"domainComponent\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"uriQuery\",\n  \"symbols\": [{\n    \"literal\": \"?\"\n  }, \"queryList\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"queryList\",\n  \"symbols\": [\"queryList\", {\n    \"literal\": \"&\"\n  }, \"queryFragment\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"queryList\",\n  \"symbols\": [\"queryFragment\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"queryFragment\",\n  \"symbols\": [\"queryFragment\", {\n    \"literal\": \"=\"\n  }, \"urlSafePlusEncoded\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"queryFragment\",\n  \"symbols\": [\"urlSafePlusEncoded\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"uriFragment\",\n  \"symbols\": [{\n    \"literal\": \"#\"\n  }, \"queryList\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"domainComponent$ebnf$1\",\n  \"symbols\": []\n}, {\n  \"name\": \"domainComponent$ebnf$1\",\n  \"symbols\": [\"domainComponent$ebnf$1\", /[a-zA-Z0-9\\-]/],\n  \"postprocess\": d => d[0].concat([d[1]])\n}, {\n  \"name\": \"domainComponent\",\n  \"symbols\": [/[a-zA-Z]/, \"domainComponent$ebnf$1\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"singleWord\"]\n}, {\n  \"name\": \"number\",\n  \"symbols\": [\"_number\"],\n  \"postprocess\": ([n]) => {\n    console.log('number', n);\n    return parseFloat(n);\n  }\n}, {\n  \"name\": \"_number\",\n  \"symbols\": [\"_float\", {\n    \"literal\": \"e\"\n  }, \"digit\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"_number\",\n  \"symbols\": [\"_float\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"_float\",\n  \"symbols\": [\"digit\", {\n    \"literal\": \".\"\n  }, \"digit\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"_float\",\n  \"symbols\": [\"digit\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"digit\",\n  \"symbols\": [\"digit\", /[0-9]/],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"digit\",\n  \"symbols\": [/[0-9]/],\n  \"postprocess\": ([tok]) => tok.text\n}, {\n  \"name\": \"urlSafePlusEncoded\",\n  \"symbols\": [\"urlSafePlusEncoded\", \"urlSafePlusEncodedChars\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlSafePlusEncoded\",\n  \"symbols\": [\"urlSafePlusEncodedChars\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"urlSafePlusEncodedChars\",\n  \"symbols\": [{\n    \"literal\": \"%\"\n  }, \"hexDigit\", \"hexDigit\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlSafePlusEncodedChars\",\n  \"symbols\": [{\n    \"literal\": \"&\"\n  }, {\n    \"literal\": \"a\"\n  }, {\n    \"literal\": \"m\"\n  }, {\n    \"literal\": \"p\"\n  }, {\n    \"literal\": \";\"\n  }],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlSafePlusEncodedChars\",\n  \"symbols\": [\"urlSafeChar\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"literal\",\n  \"symbols\": [\"string\"],\n  \"postprocess\": ([v]) => [v, {\n    string: true\n  }]\n}, {\n  \"name\": \"literal\",\n  \"symbols\": [\"singleWord\"],\n  \"postprocess\": ([v]) => [v, {\n    string: true\n  }]\n}, {\n  \"name\": \"literal\",\n  \"symbols\": [\"uri\"],\n  \"postprocess\": ([v]) => [v, {\n    uri: true\n  }]\n}, {\n  \"name\": \"literal\",\n  \"symbols\": [\"number\"],\n  \"postprocess\": ([v]) => [v, {\n    number: true\n  }]\n}, {\n  \"name\": \"singleWord$ebnf$1\",\n  \"symbols\": []\n}, {\n  \"name\": \"singleWord$ebnf$1\",\n  \"symbols\": [\"singleWord$ebnf$1\", /[a-zA-Z0-9$_]/],\n  \"postprocess\": d => d[0].concat([d[1]])\n}, {\n  \"name\": \"singleWord\",\n  \"symbols\": [/[a-zA-Z$_]/, \"singleWord$ebnf$1\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"singleWord\"]\n}, {\n  \"name\": \"word\",\n  \"symbols\": [\"word\", \"wordSafeChar\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"word\",\n  \"symbols\": [\"wordStartChar\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"wordSafeChar\",\n  \"symbols\": [\"wordStartChar\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"wordSafeChar\",\n  \"symbols\": [/[0-9]/],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"wordStartChar\",\n  \"symbols\": [/[a-zA-Z$_]/],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"string$ebnf$1\",\n  \"symbols\": [{\n    \"literal\": \"`\"\n  }],\n  \"postprocess\": id\n}, {\n  \"name\": \"string$ebnf$1\",\n  \"symbols\": [],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"string\",\n  \"symbols\": [{\n    \"literal\": \"`\"\n  }, \"_escapedString\", \"string$ebnf$1\"],\n  \"postprocess\": ([quote, string]) => string\n}, {\n  \"name\": \"_string\",\n  \"symbols\": [],\n  \"postprocess\": function () {\n    return \"\";\n  }\n}, {\n  \"name\": \"_string\",\n  \"symbols\": [\"_string\", \"_stringchar\"],\n  \"postprocess\": ([lhs, rhs]) => lhs + rhs\n}, {\n  \"name\": \"_stringchar\",\n  \"symbols\": [/[^\\\\\"]/],\n  \"postprocess\": id\n}, {\n  \"name\": \"_stringchar\",\n  \"symbols\": [{\n    \"literal\": \"\\\\\"\n  }, /[^]/],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"hexDigit\",\n  \"symbols\": [/[0-9a-fA-F]/],\n  \"postprocess\": id\n}, {\n  \"name\": \"urlSafe\",\n  \"symbols\": [\"urlSafe\", \"urlSafeChar\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"urlSafe\",\n  \"symbols\": [\"urlSafeChar\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"urlSafeChar\",\n  \"symbols\": [/[a-zA-Z0-9\\-]/],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"_escapedString\",\n  \"symbols\": [\"_escapedString\", \"escapedChar\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"_escapedString\",\n  \"symbols\": [\"escapedChar\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"escapedChar\",\n  \"symbols\": [_lexer__WEBPACK_IMPORTED_MODULE_1__[\"space\"]],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"escapedChar\",\n  \"symbols\": [_lexer__WEBPACK_IMPORTED_MODULE_1__[\"any\"]],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"nestedScope\",\n  \"symbols\": [\"pushScope\", \"scope\", \"popScope\"],\n  \"postprocess\": ([push, scope]) => scope\n}, {\n  \"name\": \"pushScope$subexpression$1\",\n  \"symbols\": [\"inlineComment\"]\n}, {\n  \"name\": \"pushScope$subexpression$1\",\n  \"symbols\": [\"eol\"]\n}, {\n  \"name\": \"pushScope\",\n  \"symbols\": [\"pushScope$subexpression$1\", \"indent\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"popScope\",\n  \"symbols\": [\"dedent\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"endLine\",\n  \"symbols\": [\"inlineComment\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"endLine\",\n  \"symbols\": [\"eol\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"inlineComment\",\n  \"symbols\": [\"space\", \"comment\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"comment$ebnf$1\",\n  \"symbols\": [\"_escapedString\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"comment$ebnf$1\",\n  \"symbols\": [],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"comment\",\n  \"symbols\": [{\n    \"literal\": \"#\"\n  }, \"comment$ebnf$1\", _lexer__WEBPACK_IMPORTED_MODULE_1__[\"eol\"]],\n  \"postprocess\": ([operator, comment]) => comment\n}, {\n  \"name\": \"sof\",\n  \"symbols\": [_lexer__WEBPACK_IMPORTED_MODULE_1__[\"sof\"]],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"eof\",\n  \"symbols\": [_lexer__WEBPACK_IMPORTED_MODULE_1__[\"eof\"]],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"sol\",\n  \"symbols\": [_lexer__WEBPACK_IMPORTED_MODULE_1__[\"sol\"]],\n  \"postprocess\": ([tok]) => tok\n}, {\n  \"name\": \"eol\",\n  \"symbols\": [\"_\", _lexer__WEBPACK_IMPORTED_MODULE_1__[\"eol\"]],\n  \"postprocess\": ([ws, tok]) => tok\n}, {\n  \"name\": \"indent\",\n  \"symbols\": [_lexer__WEBPACK_IMPORTED_MODULE_1__[\"indent\"]],\n  \"postprocess\": ([tok]) => tok\n}, {\n  \"name\": \"dedent\",\n  \"symbols\": [_lexer__WEBPACK_IMPORTED_MODULE_1__[\"dedent\"]],\n  \"postprocess\": ([tok]) => tok\n}, {\n  \"name\": \"space\",\n  \"symbols\": [_lexer__WEBPACK_IMPORTED_MODULE_1__[\"space\"]],\n  \"postprocess\": ([tok]) => tok.value\n}, {\n  \"name\": \"_\",\n  \"symbols\": [\"_\", \"space\"],\n  \"postprocess\": ([e]) => {\n    return e ? e + ' ' : '';\n  }\n}, {\n  \"name\": \"_\",\n  \"symbols\": [],\n  \"postprocess\": () => ''\n}, {\n  \"name\": \"start\",\n  \"symbols\": [\"sof\", \"rootScope\", \"eof\"],\n  \"postprocess\": ([sof, scope]) => scope\n}, {\n  \"name\": \"rootScope\",\n  \"symbols\": [\"map\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"scope\",\n  \"symbols\": [\"map\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"map\",\n  \"symbols\": [\"map\", \"mapPairConstructor\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"addPairToMap\"]\n}, {\n  \"name\": \"map\",\n  \"symbols\": [\"map\", \"mapList\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"addListToMap\"]\n}, {\n  \"name\": \"map\",\n  \"symbols\": [\"mapPairConstructor\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"pairToMap\"]\n}, {\n  \"name\": \"map\",\n  \"symbols\": [\"mapList\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"listToMap\"]\n}, {\n  \"name\": \"mapList$subexpression$1\",\n  \"symbols\": [\"sol\", {\n    \"literal\": \"-<\"\n  }, \"endLine\"]\n}, {\n  \"name\": \"mapList\",\n  \"symbols\": [\"mapList$subexpression$1\", \"list\", {\n    \"literal\": \"/-<\"\n  }],\n  \"postprocess\": ([prefix, list]) => list\n}, {\n  \"name\": \"mapPairConstructor$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"-<\"\n  }, \"pushScope\"]\n}, {\n  \"name\": \"mapPairConstructor\",\n  \"symbols\": [\"key\", \"inlineContext\", \"mapPairConstructor$subexpression$1\", \"list\", {\n    \"literal\": \"/-<\"\n  }, \"popScope\"],\n  \"postprocess\": ([key, context, mode, scope]) => {\n    return Object(_post_ast__WEBPACK_IMPORTED_MODULE_3__[\"kvcToPair\"])(key, [scope[0]], { ...scope[1],\n      ...Object(typed_json_transform__WEBPACK_IMPORTED_MODULE_0__[\"mapToContext\"])(context)\n    });\n  }\n}, {\n  \"name\": \"mapPairConstructor\",\n  \"symbols\": [\"key\", \"pushTypedScope\", \"scope\", \"popScope\"],\n  \"postprocess\": ([key, context, scope]) => {\n    return [key, scope];\n  }\n}, {\n  \"name\": \"mapPairConstructor\",\n  \"symbols\": [\"key\", \"inlineContext\", {\n    \"literal\": \"{\"\n  }, \"scope\", {\n    \"literal\": \"}\"\n  }, \"endLine\"],\n  \"postprocess\": ([key, c_, bracket, scope]) => {\n    return [key, scope];\n  }\n}, {\n  \"name\": \"mapPairConstructor\",\n  \"symbols\": [\"key\", \"inlineContext\", \"statement\", \"mapTerminator\"],\n  \"postprocess\": ([key, c, s]) => Object(_post_ast__WEBPACK_IMPORTED_MODULE_3__[\"kvcToPair\"])(key, s, c)\n}, {\n  \"name\": \"mapPairConstructor$subexpression$2\",\n  \"symbols\": [\"sol\"]\n}, {\n  \"name\": \"mapPairConstructor$subexpression$2\",\n  \"symbols\": [\"space\"]\n}, {\n  \"name\": \"mapPairConstructor$ebnf$1\",\n  \"symbols\": [\"context\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"mapPairConstructor$ebnf$1\",\n  \"symbols\": [],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"mapPairConstructor\",\n  \"symbols\": [\"mapPairConstructor$subexpression$2\", \"mapPairConstructor$ebnf$1\", \"statement\", \"mapTerminator\"],\n  \"postprocess\": ([_, c, s]) => Object(_post_ast__WEBPACK_IMPORTED_MODULE_3__[\"statementToPair\"])(s, c)\n}, {\n  \"name\": \"mapPairConstructor\",\n  \"symbols\": [\"sol\", \"eol\"],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"mapPairConstructor\",\n  \"symbols\": [\"sol\", \"comment\"],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"mapPairConstructor\",\n  \"symbols\": [\"literal\", \"pushScope\", \"scope\"],\n  \"postprocess\": _post_errors__WEBPACK_IMPORTED_MODULE_2__[\"expectedScopeOperator\"]\n}, {\n  \"name\": \"inlineContext\",\n  \"symbols\": [\"space\", \"context\"],\n  \"postprocess\": ([_, d]) => {\n    return d;\n  }\n}, {\n  \"name\": \"inlineContext\",\n  \"symbols\": [\"space\"],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"mapTerminator$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \" \"\n  }]\n}, {\n  \"name\": \"mapTerminator$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \",\"\n  }]\n}, {\n  \"name\": \"mapTerminator$subexpression$1\",\n  \"symbols\": [\"endLine\"]\n}, {\n  \"name\": \"mapTerminator\",\n  \"symbols\": [\"mapTerminator$subexpression$1\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"listTerminator$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \",\"\n  }]\n}, {\n  \"name\": \"listTerminator$subexpression$1\",\n  \"symbols\": [\"endLine\"]\n}, {\n  \"name\": \"listTerminator\",\n  \"symbols\": [\"listTerminator$subexpression$1\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"list\",\n  \"symbols\": [\"list\", \"listConstructor\"],\n  \"postprocess\": ([array, item]) => {\n    if (item) {\n      return [...array, item];\n    }\n\n    return array;\n  }\n}, {\n  \"name\": \"list\",\n  \"symbols\": [\"listConstructor\"],\n  \"postprocess\": ([item]) => {\n    return [item];\n  }\n}, {\n  \"name\": \"listConstructor\",\n  \"symbols\": [\"key\", \"pushTypedScope\", \"scope\", \"popScope\"],\n  \"postprocess\": ([key, context, scope]) => {\n    return scope;\n  }\n}, {\n  \"name\": \"listConstructor$subexpression$1$subexpression$1\",\n  \"symbols\": [\"space\", \"context\"]\n}, {\n  \"name\": \"listConstructor$subexpression$1\",\n  \"symbols\": [\"listConstructor$subexpression$1$subexpression$1\"]\n}, {\n  \"name\": \"listConstructor$subexpression$1\",\n  \"symbols\": [\"space\"]\n}, {\n  \"name\": \"listConstructor\",\n  \"symbols\": [\"key\", \"listConstructor$subexpression$1\", {\n    \"literal\": \"{\"\n  }, \"scope\", {\n    \"literal\": \"}\"\n  }, \"endLine\"],\n  \"postprocess\": ([key, context, bracket, scope]) => {\n    return scope;\n  }\n}, {\n  \"name\": \"listConstructor$subexpression$2$subexpression$1\",\n  \"symbols\": [\"space\", \"context\"]\n}, {\n  \"name\": \"listConstructor$subexpression$2\",\n  \"symbols\": [\"listConstructor$subexpression$2$subexpression$1\"]\n}, {\n  \"name\": \"listConstructor$subexpression$2\",\n  \"symbols\": [\"space\"]\n}, {\n  \"name\": \"listConstructor\",\n  \"symbols\": [\"key\", \"listConstructor$subexpression$2\", \"statement\", \"listTerminator\"],\n  \"postprocess\": ([key, context, statement]) => {\n    return statement;\n  }\n}, {\n  \"name\": \"listConstructor$subexpression$3\",\n  \"symbols\": [\"sol\"]\n}, {\n  \"name\": \"listConstructor$subexpression$3\",\n  \"symbols\": [\"space\"]\n}, {\n  \"name\": \"listConstructor$ebnf$1$subexpression$1\",\n  \"symbols\": [\"context\"]\n}, {\n  \"name\": \"listConstructor$ebnf$1\",\n  \"symbols\": [\"listConstructor$ebnf$1$subexpression$1\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"listConstructor$ebnf$1\",\n  \"symbols\": [],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"listConstructor\",\n  \"symbols\": [\"listConstructor$subexpression$3\", \"listConstructor$ebnf$1\", \"statement\", \"listTerminator\"],\n  \"postprocess\": ([prefix, c_, [r, r_]]) => {\n    return [r, { ...r_,\n      ...c_\n    }];\n  }\n}, {\n  \"name\": \"listConstructor\",\n  \"symbols\": [\"sol\", \"eol\"],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"listConstructor\",\n  \"symbols\": [\"sol\", \"comment\"],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"multilineString$ebnf$1\",\n  \"symbols\": []\n}, {\n  \"name\": \"multilineString$ebnf$1\",\n  \"symbols\": [\"multilineString$ebnf$1\", \"stringLine\"],\n  \"postprocess\": d => d[0].concat([d[1]])\n}, {\n  \"name\": \"multilineString\",\n  \"symbols\": [\"stringLine\", \"multilineString$ebnf$1\"],\n  \"postprocess\": ([head, tail]) => {\n    const [startIndent, mls] = head;\n\n    if (tail.length) {\n      const res = tail.map(([indent, line]) => {\n        let margin = '';\n\n        if (indent > startIndent) {\n          for (let i = 0; i < indent - startIndent; i++) {\n            margin = margin + ' ';\n          }\n        }\n\n        if (line) {\n          return margin + line;\n        }\n\n        return margin;\n      });\n      return [mls, ...res].join('\\n');\n    }\n\n    return mls;\n  }\n}, {\n  \"name\": \"stringLine\",\n  \"symbols\": [\"indent\", \"multilineString\", \"dedent\"],\n  \"postprocess\": ([indent, mls]) => {\n    return [indent.indent, mls];\n  }\n}, {\n  \"name\": \"stringLine$ebnf$1\",\n  \"symbols\": [\"_escapedString\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"stringLine$ebnf$1\",\n  \"symbols\": [],\n  \"postprocess\": () => null\n}, {\n  \"name\": \"stringLine\",\n  \"symbols\": [\"sol\", \"stringLine$ebnf$1\", \"eol\"],\n  \"postprocess\": ([sol, string]) => {\n    return [sol.indent, string];\n  }\n}, {\n  \"name\": \"pushTypedScope\",\n  \"symbols\": [\"space\", \"context\", \"indent\"],\n  \"postprocess\": ([space, context]) => context\n}, {\n  \"name\": \"pushTypedScope\",\n  \"symbols\": [\"pushScope\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"context\",\n  \"symbols\": [\"context\", \"constraint\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"addPairToMap\"]\n}, {\n  \"name\": \"context\",\n  \"symbols\": [\"constraint\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"pairToMap\"]\n}, {\n  \"name\": \"constraint$subexpression$1\",\n  \"symbols\": [\"space\"]\n}, {\n  \"name\": \"constraint$subexpression$1\",\n  \"symbols\": [\"endLine\"]\n}, {\n  \"name\": \"constraint\",\n  \"symbols\": [{\n    \"literal\": \"\\\\\"\n  }, {\n    \"literal\": \"{\"\n  }, \"nestedScope\", \"sol\", {\n    \"literal\": \"}\"\n  }, \"constraint$subexpression$1\"],\n  \"postprocess\": ([directive, bracket, scope]) => scope\n}, {\n  \"name\": \"constraint$subexpression$2\",\n  \"symbols\": [\"space\"]\n}, {\n  \"name\": \"constraint$subexpression$2\",\n  \"symbols\": [\"endLine\"]\n}, {\n  \"name\": \"constraint\",\n  \"symbols\": [{\n    \"literal\": \"\\\\\"\n  }, \"literal\", {\n    \"literal\": \"{\"\n  }, \"map\", {\n    \"literal\": \"}\"\n  }, \"constraint$subexpression$2\"],\n  \"postprocess\": ([directive, key, bracket, map]) => {\n    return Object(_post_ast__WEBPACK_IMPORTED_MODULE_3__[\"kvcToPair\"])(key, map);\n  }\n}, {\n  \"name\": \"constraint$subexpression$3\",\n  \"symbols\": [\"space\"]\n}, {\n  \"name\": \"constraint$subexpression$3\",\n  \"symbols\": [\"endLine\"]\n}, {\n  \"name\": \"constraint\",\n  \"symbols\": [{\n    \"literal\": \"\\\\\"\n  }, \"literal\", \"constraint$subexpression$3\"],\n  \"postprocess\": ([directive, property]) => Object(_post_ast__WEBPACK_IMPORTED_MODULE_3__[\"statementToPair\"])(property)\n}, {\n  \"name\": \"key$subexpression$1\",\n  \"symbols\": [\"sol\"]\n}, {\n  \"name\": \"key$subexpression$1\",\n  \"symbols\": [\"space\"]\n}, {\n  \"name\": \"key\",\n  \"symbols\": [\"key$subexpression$1\", \"keyExpression\", {\n    \"literal\": \":\"\n  }],\n  \"postprocess\": ([_, k]) => k\n}, {\n  \"name\": \"keyExpression$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"=\"\n  }]\n}, {\n  \"name\": \"keyExpression$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"+\"\n  }]\n}, {\n  \"name\": \"keyExpression$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"|\"\n  }]\n}, {\n  \"name\": \"keyExpression$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"&\"\n  }]\n}, {\n  \"name\": \"keyExpression$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"^\"\n  }]\n}, {\n  \"name\": \"keyExpression$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"-\"\n  }]\n}, {\n  \"name\": \"keyExpression\",\n  \"symbols\": [\"keyExpression$subexpression$1\", \"space\", \"statement\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"join\"]\n}, {\n  \"name\": \"keyExpression\",\n  \"symbols\": [\"concat\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"statement\",\n  \"symbols\": [\"concat\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"concat\",\n  \"symbols\": [\"concat\", \"space\", \"boolean\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"concat\"]\n}, {\n  \"name\": \"concat\",\n  \"symbols\": [\"boolean\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"boolean$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"n\"\n  }]\n}, {\n  \"name\": \"boolean$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"|\"\n  }]\n}, {\n  \"name\": \"boolean\",\n  \"symbols\": [\"boolean\", \"space\", \"boolean$subexpression$1\", \"space\", \"add\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"operate\"]\n}, {\n  \"name\": \"boolean\",\n  \"symbols\": [\"add\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"add$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"+\"\n  }]\n}, {\n  \"name\": \"add$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"-\"\n  }]\n}, {\n  \"name\": \"add\",\n  \"symbols\": [\"add\", \"space\", \"add$subexpression$1\", \"space\", \"multiply\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"operate\"]\n}, {\n  \"name\": \"add\",\n  \"symbols\": [\"multiply\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"multiply$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"*\"\n  }]\n}, {\n  \"name\": \"multiply$subexpression$1\",\n  \"symbols\": [{\n    \"literal\": \"/\"\n  }]\n}, {\n  \"name\": \"multiply\",\n  \"symbols\": [\"multiply\", \"space\", \"multiply$subexpression$1\", \"space\", \"unaryPrefix\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"operate\"]\n}, {\n  \"name\": \"multiply\",\n  \"symbols\": [\"unaryPrefix\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"unaryPrefix\",\n  \"symbols\": [{\n    \"literal\": \"+\"\n  }, \"group\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"unaryOperate\"]\n}, {\n  \"name\": \"unaryPrefix\",\n  \"symbols\": [{\n    \"literal\": \"-\"\n  }, \"group\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"unaryOperate\"]\n}, {\n  \"name\": \"unaryPrefix\",\n  \"symbols\": [{\n    \"literal\": \"!\"\n  }, \"group\"],\n  \"postprocess\": _post_ast__WEBPACK_IMPORTED_MODULE_3__[\"unaryOperate\"]\n}, {\n  \"name\": \"unaryPrefix\",\n  \"symbols\": [\"group\"],\n  \"postprocess\": id\n}, {\n  \"name\": \"group\",\n  \"symbols\": [{\n    \"literal\": \"(\"\n  }, \"concat\", {\n    \"literal\": \")\"\n  }],\n  \"postprocess\": ([_, g]) => g\n}, {\n  \"name\": \"group\",\n  \"symbols\": [\"literal\"],\n  \"postprocess\": id\n}];\nvar ParserStart = \"start\";\n\n//# sourceURL=webpack:///./src/nearley/index.ts?");

/***/ }),

/***/ "./src/nearley/lexer.ts":
/*!******************************!*\
  !*** ./src/nearley/lexer.ts ***!
  \******************************/
/*! exports provided: space, any, startRule, indent, dedent, sof, sol, eof, eol, lexer, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"space\", function() { return space; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"any\", function() { return any; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startRule\", function() { return startRule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"indent\", function() { return indent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dedent\", function() { return dedent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sof\", function() { return sof; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sol\", function() { return sol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eof\", function() { return eof; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eol\", function() { return eol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lexer\", function() { return lexer; });\n/// <reference path=\"../../interfaces/index.d.ts\" />\nconst moo = __webpack_require__(/*! moo */ \"../../node_modules/moo/moo.js\");\n\nconst makeToken = (type, text, sourceMap, indent) => ({ ...sourceMap,\n  type,\n  text,\n  value: text,\n  indent,\n  toString: () => text\n});\n\nconst makeSol = (sourceMap, indent) => {\n  const t = makeToken('sol', '\\n', sourceMap, indent); //console.log(t);\n\n  return t;\n};\n\nconst makeEol = (sourceMap, indent) => makeToken('eol', '\\n', sourceMap, indent);\n\nconst makeIndent = (sourceMap, indent) => makeToken('indent', 'indent', sourceMap, indent);\n\nconst makeDedent = (sourceMap, indent) => makeToken('dedent', 'dedent', sourceMap, indent);\n\nconst makeSof = () => makeToken('sof', 'sof', {\n  line: 0,\n  col: 0\n}, -1);\n\nconst makeEof = () => makeToken('eof', 'eof', {\n  line: -1,\n  col: -1\n}, -1);\n\nconst doDedent = (ruleMap, indent, nextIndent, sourceMap) => {\n  const tokens = [makeEol(sourceMap, indent)];\n  const ruleToken = ruleMap.get(indent);\n\n  if (ruleToken) {\n    tokens.push(makeToken('stopRule', `/${ruleToken.text}`, sourceMap, indent));\n    ruleMap.delete(indent);\n  }\n\n  tokens.push(makeDedent(sourceMap, nextIndent));\n  tokens.push(makeSol(sourceMap, nextIndent));\n  return tokens;\n};\n\nfunction* indented(lexer, source, info) {\n  let iter = peekable(lexer.reset(source, info));\n  let stack = [];\n  let ruleMap = new Map(); // absorb initial blank lines and indentation\n\n  let indent = iter.nextIndent();\n  yield makeSof();\n  yield makeSol(null, indent);\n\n  for (let tok; tok = iter.next();) {\n    const sourceMap = {\n      line: tok.line,\n      col: tok.col\n    };\n\n    if (tok.type === 'eol' || tok.type === 'startRule') {\n      const newIndent = iter.nextIndent();\n\n      if (newIndent == null) {\n        break;\n      } // eof\n      else if (newIndent === indent) {\n          if (tok.type === 'startRule') {\n            const ruleToken = makeToken('startRule', tok.text.slice(0, tok.text.indexOf('<') + 1));\n            ruleMap.set(indent, ruleToken);\n            yield ruleToken;\n          }\n\n          yield makeEol(sourceMap, indent);\n          yield makeSol(sourceMap, indent);\n        } else if (newIndent > indent) {\n          stack.push(indent);\n          indent = newIndent;\n\n          if (tok.type === 'startRule') {\n            const ruleToken = makeToken('startRule', tok.text.slice(0, tok.text.indexOf('<') + 1));\n            ruleMap.set(indent, ruleToken);\n            yield ruleToken;\n          }\n\n          yield makeEol(sourceMap, indent);\n          yield makeIndent(sourceMap, indent);\n          yield makeSol(sourceMap, indent);\n        } else if (newIndent < indent) {\n          while (newIndent < indent) {\n            const nextIndent = stack.pop();\n            const dedentTokens = doDedent(ruleMap, indent, nextIndent, sourceMap);\n\n            for (const t of dedentTokens) {\n              yield t;\n            }\n\n            indent = nextIndent;\n          }\n\n          if (newIndent !== indent) {\n            throw new Error(`inconsistent indentation ${newIndent} != ${indent}`);\n          }\n        } else {\n          yield makeEol(sourceMap, indent);\n          yield makeSol(sourceMap, indent);\n        }\n\n      indent = newIndent;\n    } else {\n      yield { ...tok,\n        indent: indent\n      };\n    }\n  } // dedent remaining blocks at eof\n\n\n  for (let i = stack.length; i--;) {\n    const nextIndent = stack.pop() || 0;\n    const dedentTokens = doDedent(ruleMap, indent, nextIndent, {\n      line: 'eof',\n      col: 'eof'\n    });\n\n    for (const t of dedentTokens) {\n      yield t;\n    }\n\n    indent = nextIndent;\n  }\n\n  yield makeEol({\n    line: -1,\n    col: -1\n  }, indent);\n  const ruleToken = ruleMap.get(0);\n\n  if (ruleToken) {\n    yield makeToken('stopRule', `/${ruleToken.text}`);\n    ruleMap.delete(0);\n  }\n\n  yield makeEof();\n}\n\nfunction peekable(lexer) {\n  let here = lexer.next();\n  return {\n    next() {\n      const old = here;\n      here = lexer.next();\n      return old;\n    },\n\n    peek() {\n      return here;\n    },\n\n    nextIndent() {\n      for (let tok; tok = this.peek();) {\n        if (tok.type === 'eol') {\n          this.next();\n        } else if (tok.type === 'space') {\n          // const indent = tok.value.length;\n          const recur = indent => {\n            this.next();\n            const next = this.peek();\n            if (!next) return indent;\n\n            if (next.type === 'eol') {\n              this.next();\n              return indent;\n            } else if (next.type === 'space') {\n              return recur(indent + 1);\n            }\n\n            return indent;\n          };\n\n          return recur(1);\n        }\n\n        return 0;\n      }\n    }\n\n  };\n}\n\nconst rules = {\n  space: /[ ]/,\n  startRule: {\n    match: /[a-zA-Z+\\-`]+<[\\n\\r]|[a-zA-Z+\\-`]+< #.*[\\n\\r]/,\n    lineBreaks: true\n  },\n  eol: {\n    match: /[\\n\\r]/,\n    lineBreaks: true\n  },\n  any: /[^\\s]/\n};\n\nconst printToken = t => {\n  switch (t.type) {\n    case \"eol\":\n      return \"}\";\n\n    case \"eol\":\n      return \"}\";\n\n    case \"space\":\n      return \" \";\n\n    case \"indent\":\n      return \"->\";\n\n    case \"dedent\":\n      return \"<-\";\n\n    case \"eof\":\n      return \"</>\";\n\n    case \"sof\":\n      return \"<>\";\n\n    case \"sol\":\n      return \"{\";\n\n    default:\n      return t.text;\n  }\n};\n\nclass StreamLexer {\n  constructor() {\n    this.lexer = void 0;\n\n    this.next = function () {\n      const tok = this.generator.next().value;\n\n      if (tok) {\n        //console.log(printToken(tok), tok);\n        return tok;\n      }\n    };\n\n    this.save = function () {};\n\n    this.getTokenTypes = function (source) {\n      const types = [];\n      const iter = indented(moo.compile(rules), source);\n      const arr = [];\n\n      for (const t of iter) {\n        if (t.type == 'any') {\n          const back = arr.length ? arr[arr.length - 1] : null;\n\n          if (back && back.type == 'any') {\n            back.value += t.value;\n            back.text += t.text;\n          } else {\n            arr.push(t);\n          }\n        } else {\n          arr.push(t);\n        }\n      }\n\n      return arr.map(t => printToken(t));\n    };\n\n    this.reset = function (source, info) {\n      // console.log('tokens', this.getTokenTypes(source))\n      this.generator = indented(this.lexer, source, info);\n    };\n\n    this.formatError = function (token) {\n      return this.lexer.formatError(token);\n    };\n\n    this.has = function (name) {\n      if (name == 'indent') return true;\n      if (name == 'dedent') return true;\n      if (name == 'sof') return true;\n      if (name == 'sol') return true;\n      if (name == 'eof') return true;\n      if (name == 'eol') return true;\n      return this.lexer.has(name);\n    };\n\n    this.lexer = moo.compile(rules);\n  }\n\n}\n\nconst space = {\n  test: tok => tok.type == 'space'\n};\nconst any = {\n  test: tok => tok.type == 'any'\n};\nconst startRule = {\n  test: tok => tok.type == 'startRule'\n};\nconst indent = {\n  test: tok => tok.type == 'indent'\n};\nconst dedent = {\n  test: tok => tok.type == 'dedent'\n};\nconst sof = {\n  test: tok => {\n    console.log('sof?', tok);\n    return tok.type == 'sof';\n  }\n};\nconst sol = {\n  test: tok => tok.type == 'sol'\n};\nconst eof = {\n  test: tok => tok.type == 'eof'\n};\nconst eol = {\n  test: tok => tok.type == 'eol'\n};\nconst lexer = new StreamLexer();\n/* harmony default export */ __webpack_exports__[\"default\"] = (lexer);\n\n//# sourceURL=webpack:///./src/nearley/lexer.ts?");

/***/ }),

/***/ "./src/nearley/post/ast.ts":
/*!*********************************!*\
  !*** ./src/nearley/post/ast.ts ***!
  \*********************************/
/*! exports provided: unaryOperate, operate, concat, _addPair, listToMap, addPairToMap, pairToMap, kvcToPair, statementToPair, addListToMap, join, singleWord */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unaryOperate\", function() { return unaryOperate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"operate\", function() { return operate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"concat\", function() { return concat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_addPair\", function() { return _addPair; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"listToMap\", function() { return listToMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addPairToMap\", function() { return addPairToMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pairToMap\", function() { return pairToMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"kvcToPair\", function() { return kvcToPair; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"statementToPair\", function() { return statementToPair; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addListToMap\", function() { return addListToMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"join\", function() { return join; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"singleWord\", function() { return singleWord; });\n/* harmony import */ var typed_json_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typed-json-transform */ \"../typed-json-transform/lib/index.js\");\n/* harmony import */ var typed_json_transform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(typed_json_transform__WEBPACK_IMPORTED_MODULE_0__);\n // const expand = (d: any[]) => ({\n//     $: d[0],\n//     _: d[1]\n// });\n\nconst unaryOperate = ([op, rhs]) => ({\n  [op]: rhs\n});\nconst operate = ([lhs, s1, op, s2, rhs]) => ({\n  [op]: [lhs, rhs]\n});\nconst concat = ([lhs, s1, rhs]) => ({\n  '<<': [lhs, rhs]\n});\nconst _addPair = ([l, l_], [[k, k_], [v, v_]]) => {\n  if (l.get(k)) {\n    throw new Error(`duplicate key ${k}`);\n  }\n\n  l.set(k, v);\n  l_[k] = v_;\n};\nconst listToMap = ([r]) => {\n  const l = [new Map(), {\n    map: true\n  }];\n\n  if (r && r.length) {\n    for (let i = 0; i < r.length; i++) {\n      _addPair(l, [i, r[i]]);\n    }\n  }\n\n  return l;\n};\nconst addPairToMap = ([_l, r]) => {\n  if (!r) return _l;\n  const l = Object(typed_json_transform__WEBPACK_IMPORTED_MODULE_0__[\"clone\"])(_l);\n\n  _addPair(l, r);\n\n  return l;\n};\nconst pairToMap = ([r]) => {\n  const l = [new Map(), {\n    map: true\n  }];\n\n  _addPair(l, r);\n\n  return l;\n};\nconst kvcToPair = ([k, k_], statement, c_) => {\n  if (c_) {\n    const context = Object(typed_json_transform__WEBPACK_IMPORTED_MODULE_0__[\"mapToObject\"])(c_[0]);\n    return [[k, {\n      key: true,\n      ...k_\n    }], [statement[0], { ...statement[1],\n      ...context\n    }]];\n  }\n\n  return [[k, {\n    key: true,\n    ...k_\n  }], statement];\n};\nconst statementToPair = ([s, s_], c_) => {\n  const pair = [[s, {\n    key: true,\n    ...s_\n  }], [true, {\n    boolean: true,\n    ...c_\n  }]];\n  return pair;\n};\nconst addListToMap = ([_l, r]) => {\n  const l = Object(typed_json_transform__WEBPACK_IMPORTED_MODULE_0__[\"clone\"])(_l);\n\n  if (r && r.length) {\n    for (let i = 0; i < r.length; i++) {\n      _addPair(l, [[i], r[i]]);\n    }\n  }\n\n  return l;\n};\nfunction join(list) {\n  if (list.length == 1) {\n    return list[0];\n  }\n\n  let memo = '';\n\n  for (const item of list) {\n    memo = memo + item;\n  }\n\n  return memo;\n}\n\nconst char = t => t.text;\n\nconst chars = list => list.map(char).join('');\n\nfunction singleWord(list) {\n  const head = list[0];\n  const tail = list[1];\n  let data;\n\n  if (tail && tail.length) {\n    data = head.value + chars(tail);\n  } else {\n    data = head.value;\n  }\n\n  return data;\n}\n\n//# sourceURL=webpack:///./src/nearley/post/ast.ts?");

/***/ }),

/***/ "./src/nearley/post/errors.ts":
/*!************************************!*\
  !*** ./src/nearley/post/errors.ts ***!
  \************************************/
/*! exports provided: expectedListNotation, emptyScope, expectedRhs, expectedTerminator, extraSpace, genericContextError, missingComma, expectedScopeOperator, missingRhs, unknownOrEmpty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expectedListNotation\", function() { return expectedListNotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"emptyScope\", function() { return emptyScope; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expectedRhs\", function() { return expectedRhs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expectedTerminator\", function() { return expectedTerminator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extraSpace\", function() { return extraSpace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genericContextError\", function() { return genericContextError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"missingComma\", function() { return missingComma; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expectedScopeOperator\", function() { return expectedScopeOperator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"missingRhs\", function() { return missingRhs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unknownOrEmpty\", function() { return unknownOrEmpty; });\nfunction expectedListNotation() {\n  throw new Error(\"expected list notation\");\n}\nfunction emptyScope() {\n  throw new Error(\"empty scope\");\n}\nfunction expectedRhs() {\n  throw new Error(\"no value for rhs\");\n}\nfunction expectedTerminator() {\n  throw new Error(\"missing map pair terminator\");\n}\nfunction extraSpace() {\n  throw new Error(\"unused space at end of line\");\n}\nfunction genericContextError() {\n  throw new Error(\"@context error\");\n}\nfunction missingComma() {\n  throw new Error(\"missing comma\");\n}\nfunction expectedScopeOperator() {\n  throw new Error(\"nested scope without scope operator\");\n}\nfunction missingRhs() {\n  throw new Error(\"rhs of pair assignment missing\");\n}\nfunction unknownOrEmpty() {\n  throw new Error(\"unknown or empty\");\n}\n\n//# sourceURL=webpack:///./src/nearley/post/errors.ts?");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./src/index ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! /home/leif/moss/web/packages/moss-lang/src/index */\"./src/index.ts\");\n\n\n//# sourceURL=webpack:///multi_./src/index?");

/***/ })

/******/ });